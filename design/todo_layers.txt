- Make all LayerStack operations sync and get rid of locking
- Don't allow to replace <html> ever. Force to replace <body> instead.
- Check new layer styles visually
  - Nested layers should have more padding
- Should we keep up.history.popTargets?
  - Should this always reset the world?
  - up.config.root.targets might not be appropriate
- Muss nach FromContent:
    if options.history == false
      options.location = false
      options.title = false
- Rename Response#url to Response#location
- Deprecate shortcuts like [up-modal] for shrink the API surface
  - people can use [up-layer=modal] to open a new modal
  - the original shortcuts could then be backwards compatible (up-layer="solo" up-flavor="modal")
- Is { peel: true } a good default for up.change()?
  - E.g. up.destroy() does not peel because it is not a change
  - Only user interactions ({ navigate: true }? follow? submit? UJS handlers?) should trigger peeling
- { peel } option for up.destroy
- Have up.layer.build delegate to up.Layer class
- Rename { navigate } to { solo }. Then MAYBE use { navigate } to mass-set { peel, solo, feedback }.
- Florian hatte Requirement nur Klick auf Backdrop zu vermeiden.
  - [X] close-Event sollte { origin } haben
  - [X] close-Event sollte { layer } haben
  - Wir sollten das ganze Layer compilen, nicht nur den content
- Check if all events are emitted on a close element
  - so they can be observed with up.element.on()
  - e.g. up:layer:open is being emitted on document, but it should be emitted on the parent layer element
- Should events like up:fragment:inserted also be emitted with up.layer.emit()?
  - So they will never bubble up to the parent.
  - Do we really need the weirdly behaving up.layer.emit() with boundaries if people can use up.layer.on()?
- Allow to emit an event with a response: X-Up-Emit: flight:picked { flight_id: 5 }
- Should "something:opened" event wait until the animation is done?
  - Current state
    - up:fragment:inserted    BEFORE animation starts
    - up:fragment:destroyed   AFTER animation ends
    - up:modal:opened         AFTER animation ends
    - up:modal:closed         AFTER animation ends
  - Emitting these events earlier would minimize the window for concurrency issues.
    Example:

        up.layer.open({
          url: '/foo',
          onOpened: (event) => {
            up.layer.on('flight:selected', () => up.layer.close())
          }
        })

    A save way to write this (event with late events) would also be

        up.layer.open({
          url: '/foo',
          onOpened: (event) => {
            event.layer.on('flight:selected', () => event.layer.close())
          }
        })
  - Should promises resolve earlier as well?
  - What about elements that are being removed but are still in an animation/transition?
  - What about callers who really want to wait until an animation is done?
    - An alternative would be to emit new events
      - up:fragment:inserting
      - up:layer:opening
      - up:layer:closing
      - up:fragment:destroying
    - It's a little hard to distinguish between "open" and "opening", but language-wise it's OK
      - Command: open the modal!
      - I'm in the process: modal opening!
      - I'm done: Modal opened!
    - Introducing gerund-form events would be backwards-compatible
      - To be 100% consistent, we would need to introduce up:fragment:inserting and emit up:fragment:inserted later
      - To be 100% consistent, we would need to introduce up:fragment:destroying (up:fragment:destroyed is already emitted later)
    - We could also do this for layers only right now and rework the fragment evens later
- Make sure all Change#execute() functions check if they're still applicable (or if the layer has been removed)
- Should layer-related events be emitted on the layer or the parent layer?
  - This is really only relevant for global event handlers that are not passed to the open() method, so the story pattern is save
  - We emit open-related events on the parent, so there is some symmetry to also open close-related events there
    - If we reversed this (emit close-related events on the closing layer)
      AND a parent layer is interested in their child closing, it could bind to the newly opened layer.
  - What about an layer that does not want to be dismissed if it has changes?
    - That can use up.on('up:layer:close')
  - Or should up.layer.emit events bubble up the layer hierarchy?
    - That kinda breaks the abstraction that layers are isolated
  - A lot of other options are controlled from the view of the parent layer
  - Or should we nest layer elements for this one reason?
    - Would not be great for accessibility, it's easier to hide individual layers as it is now
    - Would again break isolation
  - At least the closed event needs to be emitted on the parent! Since the layer is no longer there
  - What's your expectation for up.layer.on('up:layer:accepted', fn) ?
  - One strategy: Use the new layer when possible
    | up:layer:open      | parent layer (no choice)  |
    | up:layer:opening   | new layer                 |
    | up:layer:opened    | new layer                 |
    | up:layer:accept    | new layer                 |
    | up:layer:accepting | new layer                 |
    | up:layer:accepted  | parent layer (no choice)  |
- Was clasht:

    layer.on('up:layer:accepted')
    up.layer.open({ onAccepted: ... })

- Allow to pass up.Layer instances as arguments to up.emit(), up.on(), up.first() and up.all()


- Tests
  - Get tests green again
  - Test layer { context } transmission
  - Test that back button closes all layers
  - Test that up.change() can be called with { target: Element }
  - Test that up.change() can be called with { target: Element } and will find in any layer
  - Test that up.change() without { layer } option will only find in current layer
  - Test that clicking on the layer backdrop will cause dismiss on iOS (https://code.makandra.de/makandra/studyflix/commit/cf7d016a1d00797519b709cfcb27423c6adea9d2)
  - Test that [up-dismiss][up-follow] inside a layer will dismiss
  - Test that [up-dismiss][up-follow] outside a layer will follow
  - Test that peeling is not preventable by preventing up:layer:dismiss
  - Test that opening/updating an layer can reset the world if selector is unavailable
  - Test against https://github.com/unpoly/unpoly/issues/79
    - We might need to register all link handlers to a new .up-modal instead of the document
  - Test defaults inheritance in layer hierarchy
  - Test for up.TaskQueue, up.TaskQueue#asap variants, lock reusing, lock serialization
  - Test that a layer cannot have history: true if its parent has history: false
  - Test that making a layer change in an { onAccepted } callback will not deadlock the acceptance change
  - Test that layers are assigned .up-destroyed class while closing
  - Test that default targets are selectable per layer-type
  - Test that default targets are also fallbacks per layer-type

- Docs
  - Document changes in options { history } (now boolean) and { location } (now a string) changes
  - Documentation from Diff
  - up.preload() can now fail if preloading is disabled
  - Docs: up:form:submit event now has { options } to manipulate
  - Docs: up:link:follow event now has { options } to manipulate
  - Expose up.fragment.all() as experimental API
  - Update Card and Slide for Testing config (maxRequests => concurrency, preloadConcurrency, disable preloading entirely)
  - { navigate }
  - Document that up.on selector can be a function
  - I think the slow/recover events changed


Finishing up
------------

- Remove unused files after we copied all documentation
  - popup
  - modal
- Grep for TODO
- Test in all browsers
- Migrate cards
- Fix up-guide
  - Simplify content-link, modal-link, drawer-link
    - This should just be layer-link
  - up_modal.sass


Accessibility
--------------

- A11Y: current layer should get [role=dialog] and [aria-modal=true], all parent layers should get [inert] and [aria-hidden: true]. Since the root layer has no containers, we should apply this to direct children
- A11Y: check if [inert] etc. are enough to have the browser rotate focus within the layer
- A11Y: opening a layer should focus the layer, optionally to [autofocus]
- A11Y: closing a layer should focus the element that opened the layer


Bootstrap integration
---------------------

- update or stop supporting unpoly-boostrap3
- should we have unpoly-bootstrap4?


Later?
------

- Instead of a single event listener slot per layer, allow layer.addEventListener('closing')?
  - How is this different from up.layer.on('up:layer:closing') ?
- Do we want an ExtractPlan.BackButton? Turbolinks keep [up-keep] for back.
- Turn property-like API symbols into getter
  - e.g. up.layer.root instead of up.layer.root()
  - e.g. up.layer.current instead of up.layer.current()
- Support [up-target][up-class] and [up-target][up-fail-class] to set a class on the new fragment
  - But think how that would go together with [up-layer="new"][up-class="warning"]
- Support :destroy pseudo-class up up.change() target
- Do we need an API to change context from JS? from server via header?
- Make all module names uppercase.
  - In a ES6 world this would not even be so bad, or even necessary. import { Event } from 'up'. Event.emit(...).
  - Even consider dropping shortcuts so we always do up.Fragment.change(), up.Event.emit(...)
- Should up.reload / up.change etc. resolve to the updated elements?
- There should be a preload() function in up.proxy, but that should also take a request
  - For this we also need to decide whether up.proxy.preload() would reject unsafe requests
- { layer: 'swap' } - replaces the current overlay with the new layer
- { layer: 'solo' } - replaces all overlays with the new overlay


Decisions
---------

- Entscheiden ob ich die [up-modal], [up-drawer], etc. Shortcuts behalten möchte
  - Für Docs?
  - Verwirrend dass es mehrere Möglichkeiten gibt, das gleiche zu machen?
  - up-layer="new"
  => Ja, behalten
- The up.layer package object should be a looked up to "current", since TK naturally expected this to be the current layer
  => Das bringt nichts, dann kann man ja eben nicht sich was wergmerken
- Is { navigate } is really the best name for the option? Maybe { solo } or similar?
  - Keeping { navigate } means we could also use it for A11Y things
  => Gibt keine bessere Idee
- { flavor } umbenennen in { mode }, { scheme } oder { interface }
  - mode: Evtl. habe ich später mal nicht-modale Layer?
  - mode: 'modal' ist doof
  => Es ist nichts wirklich besser
- Should [up-href] be [up-url] to match { url }?
  - No, it matches HTML5 or XHTML2
- Params
  - Separate { query } and [up-query] options
  - NEVER move URL query to payload params
  - GET submissions: Form values should override, not append (set, not add) values from query
- Do I really want up.Change.ResetWorld instead of <body> as root's default target?
  - Yes, if we cannot match an overlay target we want to reset the world
  - One could argue that we only need ResetWorld when we're creating a layer or updating an overlay


