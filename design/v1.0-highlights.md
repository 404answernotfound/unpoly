******************************
*                            *
*  Unpoly 1.0: Star Citizen  *
*                            *
******************************



Motivation 1.0
==============

It's the result of many observations of my colleagues at makandra, and the limits they ran into when using Unpoly for non-trivial interactions.

- Fix existing pain paints
- Built existing patterns into the framework
- Reduce boilerplate configuration





Regarding breaking changes
==========================

You will see some major changes, but most of them map

Everything that can be forwarded to a new API style is:

Renamed events:     E.g. up.on('up:proxy:load') will automatically bind to up:request:load
Renamed functions:  E.g. up.modal.close() will call up.layer.dismiss()
Renamed modules:   up.proxy.foo() will call up.network.foo()

We still support deprecated APIs going back to 2016.



Default targets
===============

Most links don't need a target selector anymore
-----------------------------------------------

Learning: A lot of links simply replace the main content area. We often have a Rails helper like `content_link()` to set that default target.

Unpoly 1.0 lets you instead mark layer elements as default targets using the `[up-main]` attribute:

    <body>
      <div class="layout" up-main>
        <div class="layout--side">
          ...
        </div>
        <div class="layout--content">
          ...
        </div>
      </div>
    </body>

You no longer need [up-target] in a link. Use [up-follow] and the [up-main] will be replaced:

    <a href="/foo" up-follow>...</a>

If you want to replace something more specific, you can still use [up-target]:

    <a href="/foo" up-target=".profile">...</a>

Instead of using `[up-main]` you may also configure main targets globally:

    up.fragment.config.targets.push('.layout--content')


Different main targets for overlays
-----------------------------------

Learning: Overlays often use a different main selector, e.g. to exclude a navigation bar.

You may also configure different mains for different layer modes:

E.g. to exclude a navigation for overlays:

    <body>
      <div class="layout" up-main="root">
        <div class="layout--side">
          ...
        </div>
        <div class="layout--content" up-main="overlay">
          ...
        </div>
      </div>
    </body>

Or to configure overlay targets manually:

    up.layer.config.popup.targets.push('.menu')              // for popup overlays
    up.layer.config.drawer.targets.push('.menu')             // for drawer overlays
    up.layer.config.overlay.targets.push('.layout--content') // for all overlays




Targets in components
=====================

The position of a clicked link may now considered when deciding which element to replace.

In this example we have two links that replace `.card`:

    <div class="card" id="card1">
      Card #1 preview
      <a href="/cards/1" up-target=".card">Show full card #1</a>
    </div>

    <div class="card" id="card2">
      Card #2 preview
      <a href="/cards/2" up-target=".card">Show full card #2</a>
    </div>

When clicking "Sow full card #2", Unpoly 0.x would have replaced `.card`, matching the first card.

This makes it hard to use interactive components more than once in the same page.


Introducing :closest
--------------------

In Unpoly 1.0, links may refer to the closest ancestor with the `:closest` pseudo class:

    <div class="card" id="card1">
      Card #1 preview
      <a href="/cards/1" up-target=".card:closest">Show full card #1</a>
    </div>

    <div class="card" id="card2">
      Card #2 preview
      <a href="/cards/2" up-target=".card:closest">Show full card #2</a>
    </div>

When clicking "Show full card #2", Unpoly 1.0 will replace `#card2` matching the second card.

While the card container still requires a unique selector (e.g. "id=card1"), none of the content elements do need to know about it.

This also works with descendant selectors:

    <div class="card" id="card1">
      <a href="/cards/1/links" up-target=".card:closest .card-links">Show card #2 links</a>
      <div class="card-links"></div>
    </div>

    <div class="card" id="card2">
      <a href="/cards/2/links" up-target=".card:closest .card-links">Show card #2 links</a>
      <div class="card-links"></div>
    </div>

When clicking "Show card#2 links", Unpoly 1.0 will replace `#card2 .card-links'.



Layers
=======

Unpoly had some form of layers (modals, popups) since its inception, but with many limitations:

- In Unpoly 0.x you may only stack two screens (three if you count popups).
  Unpoly 1.0 will let you stack an arbitrary number of screens.

- In Unpoly 0.x overlay content can accidentally change another layer by targeting an element that only exists in the parent.
  In Unpoly 1.0 layers are fully isolated from each other, so a fragment update cannot accidentally change another layer, except when you explicitely request so.

- In Unpoly 0.x overlay  content always needed to know which element in a parent layer to target.
  In Unpoly 1.0 screens will not need to know whether it is used in an overlay or as a full page. Parent layers will know when a sub-interactions are finished when the sub-interaction reaches a given URL, or when it emits a given event.

  This last point is very important to me, since I think server-side code should mostly be unaware of Unpoly.
  An Unpoly frontend should compose existing screens in novel ways, through fragment updates and now layering.
  A welcome side effect of this architecture is that the application will also work without JavaScript.


Terminology
-----------

The root page, modals and popups are consolidated into a single term "layer".

"Overlay" is any layer that is not the root layer.

There are different "modes" of overlays: `modal`, `popup`, `drawer` and `cover`. `cover` is a new mode that covers the entire screen.



Layers are now isolated
=======================

In Unpoly 0.x you could accidentally update another layer if there was no match in the current layer.

In Unpoly 1.x layers are fully isolated. You cannot accidentally target an element in another layer:

    <a up-target=".foo">                    <!-- will only match in current layer -->

If you want to do *anything* in another layer, you use `[up-layer]`:

    <a up-target=".foo" up-layer="parent">  <!-- will only match in parent layer -->
    <a up-target=".foo" up-layer="root">    <!-- will only match in root layer -->
    <a up-target=".foo" up-layer="new">     <!-- opens a new modal overlay -->

Remember:

- Some layer = Do nothing
- Any other layer = [up-layer]
- [up-modal] => use [up-layer="modal"]
- [up-popup] => use [up-layer="popup"]


Functions are isolated, too
---------------------------

    up.fragment.first('.foo')                     // will only find in current layer
    up.fragment.first('.first', { layer: 'any' }) // will find in any layer


Most events are now related to a layer
--------------------------------------

    up.on('up:request:load', callback)       // listen to all up:request:load events
    up.layer.on('up:request:load', callback) // only listen to events originating from within this layer
                                             // ignores events bubbling up from a descendant layer

    up.emit('my:event')         // emit my:event on document
    up.layer.emit('may:event')  // emit my:event on the layer element





Values for { layer }
--------------------

current       The current layer (default)
front
any           Any first matching layer (Unpoly 0.x behavior)
closest
parent
ancestor
child
descendant
overlay
origin
new
swap



Overlay results
===============

Overlays may have a result. E.g. if the user selects a value, we consider the overlay to be "accepted" with that value.

If the user closes the, we consider the overlay to be "dimissed".

They are like a promise:

    let user = await up.layer.ask({ url: '/select-user' })

Example: Flight Picker


Ways to end a sub-interaction
============================

- Accept location
- Emit an event (up-accept-on, up-emit)

Why this is great

- You have a CRUD interaction anyway
- Now embed it into another form
- The embedded interaction must not know when it is done!


More explicit ways
------------------

- Link with up-accept
- Server accepts
- up.accept()




Improved server integration
===========================

Examples for unpoly-rails (rack-unpoly etc. might follow.)

Server can close layers

    up.layer.accept(id: 5)
    up.layer.dismiss()

Server can emit events

    up.emit('user:selected', id: 5)
    up.layer.emit('user:selected', id: 5)

Values survive redirect

Server: Knows if a request targets an overlay

    up.layer.overlay?
    up.layer.root?





Layer context
=============

It's a virtual cookie for the current tab and layer!

Not actually a cookie

Layer-specific

Can be read and changed from the server

  up.context

  up.context['foo'] = 'bar'


Why this is useful
------------------

This is useful when you want to re-use an existing interaction, but make a slight variation.

    <a href='/contacts' up-layer='new' up-context='{ "forProject": 4 }'>Pick a contact for this project</a>

In /contacts/index.erb

    <% if up.context[:forProject] %>
      Pick a project contact
    <% end %>

    ... regular view here ...





Layer History
=============

Layers without history silence history entirely, even for subsequent navigations and child layers

.up-current works in layers without history



Accessing the current layer
===========================

(maybe skip this section)

up.layer.dismiss() will close the "current" layer.
up.layer.current is set to the right layer in compilers and most events, even if that layer is not the "front" layer.

You may also retrieve the current layer for later reference:

   let savedLayer = up.layer.current
   let update = () => up.render({ content: 'foo', layer: savedLayer })
   setTimeout(update, 10000) // will update savedLayer regardless what the current






New overlay HTML structure
==========================

We now use custom elements.


Old popups:

```
<div class="up-popup">
  <div class="up-popup-content">...</div>
  <div class="up-popup-dismiss">×</div>
</div>>
```

New popups:

```
<up-popup>
  <up-popup-content>...</up-popup-content>
  <up-popup-dismiss>×</up-popup-content>
</up-popup>
```


Old modal:

```
<div class="up-modal">
  <div class="up-modal-viewport">
    <div class="up-modal-dialog">
      <div class="up-modal-content">...</div>
      <div class="up-modal-dismiss">×</div>
    </div>
  </div>
</div>
```

New modal:

```
<up-modal>
  <up-modal-viewport>
    <up-modal-box>
      <up-modal-content>...</div>
      <up-modal-dismiss>×</up-modal-dismiss>
    </up-modal-box>
  </up-modal-viewport>
</up-modal>
```

Customizing the appearance
--------------------------

If you have modified the appearance with CSS, you need to update selectors.

E.g.

Old CSS:

    .up-popup-content {
      background-color: #eeeeee;
    }

New CSS:

    up-popup-content {
      background-color: #eeeeee;
    }


The structure is no longer configurable
---------------------------------------

There is no up.modal.config.template anymore.

There is also no up.modal.flavors anymore.

You can use up:layer:opened to modify the layer as it becomes visible:

You can however add the structure in code:

    if (isChristmas()) {
      up.on('up:layer:opened', function(event) {
        up.element.affix(event.layer.element, '.santa-hat', text: 'Merry Christmas!')
      })
    }


Layer classes
-------------

You may also use up-class to add a class:

```
<a href="/confirm-erase" up-method="delete" up-layer="new" up-class="warning">Erase disk</a>
```

This will open:

```
<up-modal class="warning">
  ...
</up-modal>
```



Overlay sizes
=============

In earlier Unpoly, overlays grew with the size of the content.
Most projects have set sizes to modals.

All overlays now have set widths:

<a href="/path" up-layer="new" up-size="small">
<a href="/path" up-layer="new" up-size="medium">
<a href="/path" up-layer="new" up-size="large">

Table of default sizes:

| Mode      | Small   | Medium   | Large   |
|-----------|---------|----------|---------|
| Modal     | 350px   | 650px    | 1000px  |
| Popup     | 180px   | 300px    | 550px   |
| Drawer    | 150px   | 340px    | 600px   |
| Cover     | 100%    | 100%     | 100%    |

These are generally wider than Bootstrap's counterparts.

(Demo)


Customizing sizes
-----------------

Customizable with CSS:

```
up-modal[size=medium] up-modal-box
  width: 300px
```



New layer mode: Cover
---------------------

`cover` is a new layer mode in Unpoly 1.0. It overlays the *entire* page, including application layout and scroll bar.

```
<a href="/path" up-layer="cover">
```

You often see cover overlays on mobile apps.




Dismissability can be fine-tuned
--------------------------------

In Unpoly 0.x you could prevent a user from closing a layer with the `{ closable: false }` option.

In Unpoly 1.0 you may choose which closing methods are available to the user:

| Option                   | Effect              |
|--------------------------|---------------------|
| `{ keyDismissable }`     | Enables dimissing with escape key                |
| `{ outsideDismissable }` | Enables dismissing by clicking on the background |
| `{ buttonDismissable }`  | Adds an "X" button to the layer |

You may also enable or disable *all* closing methods together with the `{ dismissable }` option.



History in overlays
===================

In Unpoly 0.x you could use `{ history: true }` to open an overlay without updating the browser history. However, every user navigation within that overlay *would* affect history, unless you had [up-history=false] on every link. This is impractical, since a link should not need to know whether it is used within an overlay.

In Unpoly 1.0:

- When an overlay is opened without history, no contained link or form will never update history.
- When an overlay without history opens another overlay, that other overlay will never update history.




Functions resolve earlier
=========================

In Unpoly 0.x async functions didn't settle until animation fnished.

Un Unpoly 1.0 Updates and removals settle as soon as the DOM was changed. Any animation will play out after settling.

This generally makes code more responsive:

    let user = await up.layer.ask({ url: '/users/new' })
    userSelect.value = user.id

If your code *does* need to wait:

    up.render({ url: '/foo', transition: true, onAppeared: () => console.log("Transition has finished!") })

    up.destroy(element,, {
      onRemoved: () => console.log("Overlay has finished closing animation")
    })


Get rid of link helpers and macros
==================================

We had helpers like `content_links()` and macros like `[content-link]` that would:

- Make a link followable through Unpoly
- Set additional options like [up-preload] and [up-instant]
- Set a default target


Following links by default
--------------------------

You can tell Unpoly to follow *all* links:

    up.form.config.submitSelectors.push('form')
    up.link.config.followSelectors.push('a')

To allow external links and forms, skip URL containing "://":

    up.form.config.submitSelectors.push('form:not(action*="://")')
    up.link.config.followSelectors.push('a:not(href*="://")')

Note that individual links may still opt out of following by setting [up-follow=false]:

    <a href="/backend" up-follow="false">


Accelerating links by default
-----------------------------

If you want to default to [up-instant] and [up-preload]:

    up.link.config.instantSelectors.push('a')
    up.link.config.preloadSelectors.push('a')

If some links should not be accelerated (e.g. instant clicks feel wrong for buttons!), use a different CSS selector:

    up.link.config.instant.push('a':not(.btn)'')

Note that individual links may still opt out of following by setting [up-instant=false] or [up-preload=false]:

    <a href="/backend" up-instant="false">
    <a href="/expensive-path" up-preload="false">


Setting a default target
------------------------

You already learned this:

    .content              => [up-main]
    .content-for-modal    => [up-main=overlay] oder [up-main=modal]


Setting a transition for all navigations
----------------------------------------

I'm actually not a bug fan of animating every fragment update, but if you need to:

    up.fragment.config.navigateTransition = 'cross-fade'





Updates that are not navigation
===============================

People tried to replace a box on the screen, but needed many option to disable scrolling, etc.

up.render(options) does not navigate by default. Use up.navigate(options) or up.render({ ...options, navigate: true }).

THE POINTS BELOW NO LONGER CORRECT!

E.g. when updating a message counter:

    up.render({ target: '.unread-count', navigate: false })

This will set multiple options:

| Setting             | Effect                                              |
|---------------------|-----------------------------------------------------|
| `history: false`    | Don't update URL bar or document title              |
| `solo: false`       | Don't cancel existing requests                      |
| `reveal: false`     | Don't scroll to the new element                     |
| `peel: false`       | Don't close overlays when targeting a veiled layer  |
| `feedback: false`   | Don't set .up-active on the origin link             |
| `focus: false`      | Don't focus ater update                             |




AJAX
====

NO LONGER TRUE

The up.proxy package is now up.network. Conforms to pattern:

    up.thing.verb()

Many used up.request() for a cross-browser alternative to AJAX or fetch(), also to fetch JSON etc.



Direct calls to up.fetch() no longer cache by default

There is also up.Response#json

    response = await up.request('/api/v3/foo)
    console.log(response.json)


X-Up-Cache: clear
up.cache.clear




User navigation aborts earlier requests
=======================================

Earlier Unpolys had a concurrency issue on slow connections:

- User clicks link #1
- Server takes long to respond to #1
- User clicks another link #2
- Server responds with #2
- Server responds with #1
- User sees effects of #1 (but expected to see effects of #2)

User navigation now aborts existing requests:

- User clicks link #1
- Server takes long to respond to #1
- User clicks another link #2
- Unpoly cancels request for #1
- Server responds with #2
- User sees effects of #2

You may disable this with `{ solo: false }` (JS) or `[up-solo="false"]` (HTML)


Smarter bandwidth usage
=======================

NO LONGER TRUE LIKE THIS

- Preloading is now automatically disabled on slow connections
- Preload requests are aborted as the user leaves the area
- There is a single concurrency setting (default 4) for both regular requests and preload requests.
- Preload requests are aborted to make space for regular requests.
- Preload requests have a default timeout (10 seconds).
- User navigation aborts existing requests.

Slow connection?
----------------

- User has data saving enabled ("Lite mode" in Chrome)
- RTT >= 1400 ms
- Downlink <= 70 Kbps





Easy progmatic fragment changes
===============================

    up.visit(url)                 => up.render({ url })
    up.modal.visit(url)           => up.render({ url, layer: 'new' })
    up.replace(target, url)       => up.render({ target, url })
    up.extract(target, document)  => up.render({ target, document })


Every kind of fragment update accepts the same options.


Empty layer:

```
up.layer.open()
// or
```

Content without target (will open in default target):

```
up.layer.open({ content: 'foo' })
```


Change content:

```
up.render('.foo', { content: 'inner' }
```


Derive target from new outer HTML:

```
up.render({ fragment: '<div class=".foo">inner</div>' })
```





Tooltips are gone
=================

The tooltip component has been removed from Unpoly.

We want to focus on things that are hard to implement.

Alternatives:

- [Bootstrap tooltips](https://v5.getbootstrap.com/docs/5.0/components/tooltips/)
- [Balloon.css](https://kazzkiq.github.io/balloon.css/) (CSS only)
- [Plain [title] attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title) (built into the browser)

Unpoly 1.0 will convert `[up-tooltip]` to `[title]`.


Tooltips don't work on mobile
-----------------------------

Touch devices [don't really have a "hover" state](https://makandracards.com/makandra/5117-touch-devices-don-t-have-mouseover-events).

That means that classic tooltips won't work on mobile. Consider a clickable popup instead:

```
<span up-layer="popup" up-content="Locking a user will prevent them from using the application">
  Help
</span>
```



Loading error pages
===================

A new event `up:fragment:loaded` is [emitted](/up.emit) when the server responds with the HTML, before
the HTML is used to [change a fragment](/up.render).

Event listeners may call `event.preventDefault()` on an `up:fragment:loaded` event
to prevent any changes to the DOM and browser history. This is useful to detect
an entirely different page layout (like a maintenance page or fatal server error)
which should be open with a full page load:

    up.on('up:fragment:loaded', (event) => {
      let isMaintenancePage = event.response.getHeader('X-Maintenance')

      if (isMaintenancePage) {
        // Prevent the fragment update and don't update browser history
        event.preventDefault()

        // Make a full page load for the same request.
        event.request.loadPage()
      }
    })

Also up:fragment:unusable.



Accessibility
=============

Explain how important focus is.

up-nav sets [aria-current]

focus cycle in layers
focus returns after closing layer

focus controllable by user. List focus options!

  Explain default (autofocus, new layer, nothing)

Focus is preserved is possible
  Selection range
  Scroll position

Already backported to 0.62:

- Links with an [`[up-instant]`](/a-up-instant) attribute can now be followed with the keyboard.
- Fragments that are being [destroyed](/up.destroy) now get an [`[aria-hidden=true]`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-hidden_attribute)
  attribute while its disappearance is being animated. When a fragment is being swapped with a new version, the old fragment version is also
  given `[aria-hidden=true]` while it's disappearing.
- [Modal dialogs](/up.modal) now get an [`[aria-modal=true]`](https://a11ysupport.io/tech/aria/aria-modal_attribute) attribute.



Major breaking changes
======================

- Faster resolution, use onAppeared onRemoved
- failOptions (you probably won't notice)
- New HTML structure for overlays
  - Modal flavors are out
  - Custom modal templates are out
- Tooltips are just titles
- [up-layer=modal] used to mean "in an existing modal", it now means "open a new modal".


Boostrap integration
====================

Unpoly 1.0 now supports the three major Bootstrap versions we're using:

- unpoly-bootstrap3.js
- unpoly-bootstrap3.css
- unpoly-bootstrap4.js
- unpoly-bootstrap4.css
- unpoly-bootstrap5.js
- unpoly-bootstrap5.css

Integration is now minimal
--------------------------

Many projects didn't actually end up using the built-in Bootstrap integration, because it was too opinionated. E.g. Unpoly tried to re-use the Bootstrap modal styles, but most projects simply wanted the white box from the Unpoly default.

They ended up using their own configuration, which is much more minimal.

Unpoly 1.0 now ships with a **minimal Bootstrap integration**:

This is unpoly-boostrap4.js:

    // Bootstrap expects the class .active instead of .up-active
    up.feedback.config.currentClasses.push('active')

    // Set .up-current classes in Bootstrap navigation components
    up.feedback.config.navs.push('.nav', '.navbar')

    // When validating, update the closest form group with the results
    up.form.config.validateTargets.unshift('.form-group:has(&)')

    // When revealing, scroll far enough so content is not covered by
    # fixed Bootstrap bars
    up.viewport.config.fixedTop.push('.navbar.fixed-top')
    up.viewport.config.fixedBottom.push('.navbar.fixed-bottom')
    up.viewport.config.anchoredRight.push('.navbar.fixed-top', '.navbar.fixed-bottom')

    // Don't use common utility classes to build selectors
    up.fragment.config.badTargetClasses.push(
      /^row$/,
      /^col(-xs|-sm|-md|-lg|-xl)?(-\d+)?$/,
      /^[mp][tblrxy]?-\d+$/
    )

This is unpoly-bootstrap4.scss:

    // If a container is shown in an overlay, don't add to the existing
    // padding of the overlay box.
    up-modal, up-drawer, up-popup {
      .container, .container-fluid {
        padding-left: 0;
        padding-right: 0;
      }
    }


Stability
=========

- When a compiler throws an error, other compilers will now run anyway
- When a destructor throws an error, other destructors will now run anyway


New log
=======

- Flat
- Function is highlighted at the beginning


Others
======

- Focus, selection, caret is preserved when updating a fragment that contains focus


Scrolling
=========

Fragment updates don't always scroll anymore.

up.viewport.config.revealMax (defaults to 50% screen height)

All scroll-related options ({ reveal, resetScroll, restoreScroll }) etc. have been reduced to a single { scroll } option:

| scroll: 'auto'               | Scroll to the top IFF updating an [up-main] selector     |
| scroll: 'top'                | Scroll viewport to the top                               |
| scroll: 'restore'            | Restore scroll position to last known value for this URL |
| scroll: 'hash'               | Scroll to a #hash in the updated URL                     |
| scroll: 'target'             | Reveal the updated fragment                              |
| scroll: Function(options)    | Pass your own scrolling logic                            |

| { revealTop }      |  Whether to align                       | up.viewport.config.revealTop
| { revealMax }      |  How much of a high element to reveal   | up.viewport.config.revealMax
| { revealSnap }     |  When to snap to the top edge           | up.viewport.config.revealSnap
| { scrollBehavior } |  auto/smooth                            | auto (no anination)



renderOptions
=============

up:form:submit
up:form:validate
up:link:follow


    up.on('up:form:submit', function(event) {
      console.log("Form will replace " + event.renderOptions.target)
    })


Manipulate:

    up.on('up:form:submit', function(event) {
      event.renderOptions.failScroll = '.error-message'
      event.renderOptions.failTransition = 'shake'
    })


Content Security Policy (CSP)
============================

By choosing a strict CSP, you also decide against using event handlers in your HTML.

Won't work with CSP:

    <a href="/contacts/new" up-layer="new" up-accept-location="/contacts/$id" up-on-accepted="up.reload('.table')">

Move it to UJS:

    <a href="/contacts/new" class="add-contact" up-follow>

    up.on('up:link:follow', '.add-contact', function(event) {
      event.renderOptions.layer = 'new'
      event.renderOptions.acceptLocation = '/contacts/$id'
      event.renderOptions.onAccepted = (event) => { up.reload('.table') }
    })

Move it to UJS (alternative with preventDefault()):

    <a href="/contacts/new" class="add-contact">

    up.on('click', '.add-contact', function(event, link) {
      up.follow(link, {
        layer: 'new'
        acceptLocation: '/contacts/$id'
        onAccepted: (event) => { up.reload('.table') }
      })

      event.preventDefault()
    })
