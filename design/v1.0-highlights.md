

```text
******************************
*                            *
*  Unpoly 1.0: Star Citizen  *
*                            *
******************************
```


Unpoly is an unobtrusive JavaScript framework for server-side web applications.\
It enables fast and flexible frontends while keeping rendering logic on the server.

This presentation is for experienced Unpoly 0.x users who want to learn
about the major changes in Unpoly 1.0.



Motivation 1.0
==============

| Date    | Event              |
| ------- | ------------------ |
| 2018-02 | Start branch       |
| 2019-01 | `git reset --hard` |
| 2020-12 | Today              |
| 2021-01 | Release 1.0        |


It's the result of many observations of my colleagues at makandra, and the limits they ran into when using Unpoly for non-trivial interactions. For this I looked through a lot of code on our Gitlab to see how Unpoly was used.

üí° Learnings from past projects\
üéÅ New feature in Unpoly 1.0\
ü•ã Master class slides (separate session next week)


What's new?
============

Layered sub-interactions
------------------------
- Infinitely stacked layers
- Layer isolation

Navigation intent
------------------
- Not every fragment update means a user navigation
- Switching screens vs. rendering a small fragment

Reduce boilerplate
------------------
- Less userland configuration
- Built existing patterns into the framework

Be more hackable
----------------
- More config, events, options


Don't panic!
============

You will see some major changes in these slides, but **don't panic**!\
Unpoly 1.0 still supports deprecated APIs going back to 2016.

Usage of old APIs will forwarded to the new version and log a deprecation with trace.\
This way you upgrade Unpoly, revive your application with few changes, then replace old API calls under green tests.

## Renamed events are aliased

E.g. `up.on('up:proxy:load')` will bind to `up:request:load`.

## Renamed functions are aliased

E.g. `up.modal.close()` will call `up.layer.dismiss()`

## Renamed options are aliased

E.g. `{ reveal: false }` will be renamed to `{ scroll: false }`

## Renamed modules are aliased

E.g. `up.proxy.config` will return `up.network.config`.

## Renamed HTML attributes are aliased

E.g. `<a up-close>` will translate to `<a up-dismiss>`.



Actual breaking changes
=======================

There's a short list of changes that we cannot fix with aliases.\

## Overlays (modals, popups) have different HTML

But it's similar. E.g. `<div class="modal">` becomes `<up-modal>`.

## Tooltips are no longer built-in

But there are a million better libraries.

## Async functions no longer wait for animations

You might or might not notice.

## `[up-layer=modal]` means something else

It used to mean *update an existing modal*.
It now means *open a new modal*.



Delete your Unpoly link helpers
===============================

All our projects have helpers like `content_link()` and `modal_link()` to configure defaults:

- Make a link followable through Unpoly
- Accelerate clicks with `[up-preload]` and `[up-instant]`
- Set a default target
- Set a transition (sometimes)

**In Unpoly 1.0 these helpers (and their macros) are no longer needed.**\
You can now configure Unpoly to handle standard `<a href>` links without any `[up-...]` attributes.\
Rails users can now use the standard `link_to()` helper without extra options.


Following all links by default
==============================

**üí° Most apps handle all links and forms through Unpoly**

You can tell Unpoly to handle *all* links and forms:

```js
up.link.config.followSelectors.push('a')
up.form.config.submitSelectors.push('form')
```

To except external links and forms, skip URL with a schema separator (`://`):

```js
up.link.config.followSelectors.push('a:not(href*="://")')
up.form.config.submitSelectors.push('form:not(action*="://")')
```

Links will now be followed through Unpoly without an `[up-target]` or `[up-follow]` attribute:

```html
<a href="/backend">...</a>
```

Individual links or forms may still opt out of following by setting `[up-follow=false]`:

```html
<a href="/backend" up-follow="false">...</a>
```

Accelerating links by default
=============================

**üí° Most links should follow on `mousedown`  and be preloaded.**

If you want to default to `[up-instant]` and `[up-preload]`:

```js
up.link.config.instantSelectors.push('a')
up.link.config.preloadSelectors.push('a')
```

All your links now activate on `mousedown` and (with a `GET` method) preload on `mouseover`:

```html
<a href="/backend">...</a>
```

Instant clicks feel wrong for buttons. To cover that, configure a CSS selector that excludes buttons:

```js
up.link.config.instant.push('a:not(.button))
```

Individual links may opt out by setting `[up-instant=false]` or `[up-preload=false]`:

```html
<a href="/backend" up-instant="false">
<a href="/expensive-path" up-preload="false">
```


Default targets
===============
**üí° Many links simply replace the main content element.**

Most links don't need a target selector anymore
-----------------------------------------------

Unpoly 1.0 lets you mark elements as *default targets* using the `[up-main]` attribute:

```html
<body>
  <div class="layout">
    <div class="layout--side">
      ...
    </div>
    <div class="layout--content" up-main>
      ...
    </div>
  </div>
</body>
```

You no longer need `[up-target]` in a link. Use `[up-follow]` and the `[up-main]` element will be replaced:

```html
<a href="/foo" up-follow>...</a>
```

If you want to replace something more specific, you can still use `[up-target]`:

```html
<a href="/foo" up-target=".profile">...</a>
```

Instead of using `[up-main]` you may also configure an existing selector:

```js
up.fragment.config.mainTargets.push('.layout--content')
```


Different main targets for overlays
-----------------------------------

**üí° Overlays often use a different main selector, e.g. to exclude a navigation bar.**

Unpoly lets you configure different main elements for different layer modes:

E.g. to exclude a navigation sidebar for overlays:

```html
<body>
  <div class="layout" up-main="root">
    <div class="layout--side">
      ...
    </div>
    <div class="layout--content" up-main="overlay">
      ...
    </div>
  </div>
</body>
```

Or to configure overlay targets manually:

```js
up.layer.config.popup.targets.push('.menu')              // for popup overlays
up.layer.config.drawer.targets.push('.menu')             // for drawer overlays
up.layer.config.overlay.targets.push('.layout--content') // for all overlays
```

Setting a default transition
============================

I'm not a big fan of animating every fragment update.

But since some of you do this, here is how to set a default transition:

```js
up.fragment.config.navigateOptions.transition = 'cross-fade'
```

Sub-interactions
================

```
+------------+     +----------------------------+     +-----------------+
|            |     |                            |     |                 |
|  List      |     |  New                       |     |  Show           |
|  projects  +----->  project                   +----->  project        |
|            |     |                            |     |                 |
+------------+     +-----+----------------^-----+     +-----------------+
                         |                |
                         |                |
                   +-----v-----+    +-----+-----+
                   |           |    |           |
                   |  New      |    |  Create   |
                   |  company  +---->  company  |
                   |           |    |           |
                   +-----------+    +-----------+
```

Demo of new layer implementation
----------

- Show infinite stacking
- Show returning with value
- Show isolation


New layer terminology
======================

The root page, modals and popups have been consolidated into a single term *layer*.

There are different layer *modes*, e.g. `modal` or `popup`.

An *overlay* is any layer that is not the root layer.


| Mode      | Description                       | Overlay? |
| --------- | --------------------------------- | -------- |
| `root`    | The root page                     | no       |
| `modal`   | A modal dialog box                | overlay  |
| `drawer`  | A drawer sliding in from the side | overlay  |
| `popup`   | A popup menu anchored to a link   | overlay  |
| `cover` üéÅ | Covers entire screen              | overlay  |



Layers are now isolated
=======================

If we want to support sub-interactions, multiple copies of the same app must be able to run in the same document. E.g. one copy runs on the root page and a second copy runs in a modal overlay.

In Unpoly 0.x you could accidentally update another layer if there was no match in the current layer. üí•

In Unpoly 1.0 layers are fully isolated. You cannot accidentally target an element in another layer:

    <a up-target=".foo">                    <!-- will only match in current layer -->

If you want to do *anything* in another layer, you use `[up-layer]`:

    <a up-target=".foo" up-layer="parent">  <!-- will only match in parent layer -->
    <a up-target=".foo" up-layer="root">    <!-- will only match in root layer -->
    <a up-target=".foo" up-layer="new">     <!-- opens a new modal overlay -->



Functions only see the current layer by default
-----------------------------------------------

    up.fragment.first('.foo')                     // will only find in current layer
    up.fragment.first('.first', { layer: 'any' }) // will find in any layer


Values for `{ layer }` ü•ã
=========================

| Value            | Description                                                  |
| ---------------- | ------------------------------------------------------------ |
| `current`        | The current layer (Unpoly 1.0 default)                       |
| `any`            | Any layer, preferring the current layer (Unpoly 0.x default) |
| `closest`        | The current layer or any ancestor, preferring closer layers  |
| `parent`         | The layer that opened the current layer                      |
| `ancestor`       | Any ancestor layer of the current layer                      |
| `child`          | The child layer of the current layer                         |
| `descendant`     | Any descendant of the current layer                          |
| `root`           | The root layer                                               |
| `overlay`        | Any overlay                                                  |
| `origin`         | The layer of the element that triggered the current action   |
| `front`          | The frontmost layer (which might not be the current layer)   |
| `Element object` | The element's layer                                          |

When updating fragments you have two additional options:

| Value  | Description                              |
| ------ | ---------------------------------------- |
| `swap` | Replace the front layer with a new layer |
| `new`  | Open a new layer                         |



Most events are associated with a layer
======================================

**üí° Layers are not interested in events of other layers.**

Whenever possible Unpoly will emit its events on associated layers instead of `document`.\
This way you can listen to events on one layer without receiving events from other layers.

Convenience functions `up.layer.on()`  and `up.layer.emit()` to listen / emit on the current layer.

```js
up.on('up:request:load', callback)       // listen to all up:request:load events
up.layer.on('up:request:load', callback) // only listen to events originating from within this layer

up.emit('my:event')         // emit my:event on document
up.layer.emit('may:event')  // emit my:event on the layer element
```



Deprecated macros
-----------------

`[up-modal]` is deprecated. Use `[up-layer=modal]` or `[up-layer=new]` instead.

`[up-popup]` is deprecated. Use `[up-layer=popup]` instead.




Layers can be stacked infinitely
================================

In Unpoly 0.x you may only stack two screens (three if you count popups).

- The root page shows a list of record
- Clicking a record opens a record in a modal overlay. This is useful since the user retains the scroll position of the list in the background.
- üí• The details screen cannot open another modal overlay, since on is already open.

**Unpoly 1.0 lets you stack an arbitrary number of screens.**





Overlay results
===============

[Diagramm where an interaction branches off into a sub-interaction]

Overlays may have a *result*. E.g. if the user selects a value, we consider the overlay to be "accepted" with that value.

```js
up.layer.open({
  url: '/select-user',
  onAccepted: (event) => console.log('Got user ', event.user)
})
```

There is also `up.layer.ask()`  which returns a promise for the overlay's acceptance value:

```js
let user = await up.layer.ask({ url: '/select-user' })
```

Example: Flight Picker



Ending a sub-interaction
========================

In Unpoly 0.x it was very hard to communicate the "result" of a sub-interaction within an overlay back to the parent layer.

Take the following example (from the demo):

```
+------------+     +----------------------------+     +-----------------+
|            |     |                            |     |                 |
|  List      |     |  New                       |     |  Show           |
|  projects  +----->  project                   +----->  project        |
|            |     |                            |     |                 |
+------------+     +-----+----------------^-----+     +-----------------+
                         |                |
                         |                |
                   +-----v-----+    +-----+-----+
                   |           |    |           |
                   |  New      |    |  Create   |
                   |  company  +---->  company  |
                   |           |    |           |
                   +-----------+    +-----------+
```

- User starts filling out the form for a new project
- To create a project, the user must select a company. But the desired company does not yet exist.
- The user may open a new overlay to create the missing company. The unfinished project form remains open in the background.
- When the company was created in the overlay, the overlay should close. The project form should now have the newly created company selected.

This required a lot of custom code in Unpoly 0.x.
Basically overlay content needed to update fragments in the parent layer.
This required the overlay to know the parent layer's state, coupling the sub-interaction to the parent interaction.

**When opening an overlay in Unpoly 1.0, you may define a *condition* when the overlay interaction ends.**
When the condition occurs, the overlay is automatically closed and a callback is run.

This way overlays no longer need to know about the parent layer's state.
This completely decouples the outer interaction from sub-interactions.


Accepting when a location is reached
====================================

The following will open overlay will close when a URL like `/companies/123` is reached.

```html
<a href="/companies/new"
  up-layer="new"
  up-accept-location="/companies/$id"
  up-on-accepted="alert('New company with ID ' + value.id)">
  New company
</a>
```

Placeholders in the URL pattern (`$id`) become the overlay's *acceptance value*.

The callback (`[up-on-accepted]`) is called with an acceptance value.

A common callback is to reload an element in the parent layer:

```html
<a href="/companies/new"
  up-layer="new"
  up-accept-location="/companies/$id"
  up-on-accepted="up.reload('.company-list')">
  New company
</a>

<div class="company-list">
  ...
</div>
```

Another common callback reloads `<select>` options and selects the new foreign key:

```html
<select name="company">...</select>

<a href="/companies/new"
  up-layer="new"
  up-accept-location="/companies/$id"
  up-on-accepted="up.validate('select', { params: { company: value.id } })">
  New company
</a>
```

Why this is great:

- You have a CRUD interaction for users anyway
- You can now embed the existing user CRUD into your company
- The embedded interaction must not know when it is done


URL patterns
------------

| Pattern                  | Meaning                         |
| ------------------------ | ------------------------------- |
| `/users/*`               | Any prefix                      |
| `/users/1 /users/2`      | Alternatives (`OR`)             |
| `/users/:id`             | Capture segment (any string)    |
| `/users/$id`             | Capture segment (only integers) |
| `/users/:id -/users/new` | Exclude                         |



Accepting when an event is emitted
==================================

A little more explicit:

```
<a href="/users/new"
  up-layer="new"
  up-accept-event="user:created"
  up-on-accepted="alert('new user with ID ' + value.id)">
  Add a user
</a>
```

The server can emit events:

```
class UsersController < ApplicationController

  ...

  def create
    build_user
    if @user.save
      up.layer.emit('user:created', id: @user.id)
      redirect_to @user
    end
  end

end
```


Accepting a layer explictly
----------------------------

Links with [up-accept]:

    <a href='/companies/5' up-accept='{ "id": 123 }'>Use company #5</a>

Server may also accept:

    class UsersController < ApplicationController

      ...

      def create
        build_user
        if @user.save
          if up.overlay?
            up.layer.accept(id: @user.id)
            render :nothing
          else
            redirect_to @user
          end
        end
      end

    end



Positive vs. negative close intent
==================================

When an overlay is closed, Unpoly 1.0 distinguishes two kinds close intents:

- Accepting a layer (user presses "OK", sub-interaction completes successfully), optionally with a value
- Dismissing a layer (user presses "Cancel", "X", "Close" or Escape)

[Show selection dialog with differences intents for selection, cancel button, X button, background click, escape click]

onAccepted und onDismissed callbacks:

    up.layer.open({
      url: '/users/new',
      onAccepted: (event) => console.log("New user is " + event.value)
      onDismissed: (event) => console.log("User creation was canceled")
    })

Think of it as async promises which may either be fulfilled or rejected.

`up.layer.ask()` returns a promise for the acceptance value:

    let user = await up.layer.ask({ url: '/users/new' })
    console.log("New user is " + user)





Layer context ü•ã
=============

It's a virtual cookie for the current tab and layer (not actually a cookie).

Is sent as an X-Up-Context header with every request.

Layer-specific

Can be read and changed from the server

    up.context

    up.context['foo'] = 'bar'


Why this is useful
------------------

This is useful when you want to re-use an existing interaction, but make a slight variation.

    <a href='/contacts' up-layer='new' up-context='{ "forProject": 4 }'>Pick a contact for this project</a>

In /contacts/index.erb

    <% if up.context[:forProject] %>
      Pick a project contact
    <% end %>

    ... regular view here ...




Accessing the current layer ü•ã
=============================

(maybe skip this section)

up.layer.dismiss() will close the "current" layer.
up.layer.current is set to the right layer in compilers and most events, even if that layer is not the "front" layer.

You may also retrieve the current layer for later reference:

   let savedLayer = up.layer.current
   let update = () => up.render({ content: 'foo', layer: savedLayer })
   setTimeout(update, 10000) // will update savedLayer regardless what the current



Customizing layer appearance
============================


New overlay HTML structure
---------------------------

If you have customized your modals and popup with CSS, this is a breaking change for you.

Luckily the new HTML structure is very similiar. E.g. `<div class="modal">` becomes `<up-modal>`.

### Old popup HTML

```html
<div class="up-popup">
  <div class="up-popup-content">...</div>
  <div class="up-popup-dismiss">√ó</div>
</div>>
```

### New popup HTML

```html
<up-popup>
  <up-popup-content>...</up-popup-content>
  <up-popup-dismiss>√ó</up-popup-content>
</up-popup>
```


### Old modal HTML

```html
<div class="up-modal">
  <div class="up-modal-viewport">
    <div class="up-modal-dialog">
      <div class="up-modal-content">...</div>
      <div class="up-modal-dismiss">√ó</div>
    </div>
  </div>
</div>
```

### New modal HTML

```html
<up-modal>
  <up-modal-viewport>
    <up-modal-box>
      <up-modal-content>...</div>
      <up-modal-dismiss>√ó</up-modal-dismiss>
    </up-modal-box>
  </up-modal-viewport>
</up-modal>
```

Customizing with CSS
--------------------

If you have modified the appearance with CSS, you need to update selectors.

### Old CSS

```css
.up-popup-content {
  background-color: #eeeeee;
}
```

### New CSS

```css
up-popup-content {
  background-color: #eeeeee;
}
```




Customizing the HTML structure
------------------------------

There is no up.modal.config.template anymore.

There is also no up.modal.flavors anymore.

You can use up:layer:opened to modify the layer as it becomes visible:

    if (isChristmas()) {
      up.on('up:layer:opened', function(event) {
        up.element.affix(event.layer.element, '.santa-hat', text: 'Merry Christmas!')
      })
    }



Overlay classes
---------------

You may also use [up-class] to add a class:

```
<a href="/confirm-erase" up-method="delete" up-layer="new" up-class="warning">Erase disk</a>
```

This will open:

```
<up-modal class="warning">
  ...
</up-modal>
```

You can now style "warning modals" in your CSS:

```
up-modal.warning {
  background-color: yellow
}
```



Overlay sizes
-------------

In earlier Unpoly, overlays grew with the size of the content.
This was impractical because a single long line of text would stretch the overlay to its maximum width.

Because of this most projects have configured modals to have a fixed size.
Many projects also have hacks to open modals with different sizes.

In Unpoly 1.0 all overlays have a given size that sets a maximum width:

    <a href="/path" up-layer="new" up-size="small">
    <a href="/path" up-layer="new" up-size="medium"> <!-- default -->
    <a href="/path" up-layer="new" up-size="large">

Table of default sizes:

| Mode   | Small | Medium | Large  |
| ------ | ----- | ------ | ------ |
| Modal  | 350px | 650px  | 1000px |
| Popup  | 180px | 300px  | 550px  |
| Drawer | 150px | 340px  | 600px  |
| Cover  | 100%  | 100%   | 100%   |

These are generally wider than Bootstrap's counterparts.

Regardless of size, overlays never grow wider than the screen width.

(Demo)


### Customizing sizes

Customizable with CSS:

```
up-modal[size=medium] up-modal-box {
  width: 300px;
}
```

Dismissability can be fine-tuned
================================

In Unpoly 0.x you could prevent a user from closing a layer with the `{ closable: false }` option.

In Unpoly 1.0 you may choose which closing methods are available to the user:

| Option                   | Effect                                           | Dismiss value |
| ------------------------ | ------------------------------------------------ | ------------- |
| `{ keyDismissable }`     | Enables dimissing with escape key                | `':key'`      |
| `{ outsideDismissable }` | Enables dismissing by clicking on the background | `':outside'`  |
| `{ buttonDismissable }`  | Adds an "X" button to the layer                  | `':button`'   |

You may also enable or disable *all* closing methods together with the `{ dismissable }` option.




New layer mode: Cover
=====================

`cover` is a new layer mode in Unpoly 1.0. It overlays the *entire* page, including application layout and scroll bar.

```
<a href="/path" up-layer="cover">
```

You often see cover overlays on mobile apps.



History in overlays
===================

In Unpoly 0.x you could use `{ history: true }` to open an overlay without updating the browser history. However, every user navigation within that overlay *would* affect history, unless you had [up-history=false] on every link. This is impractical, since a link should not need to know whether it is used within an overlay.

In Unpoly 1.0:

- When an overlay is opened without history, no contained link or form will never update history.
- When an overlay without history opens another overlay, that other overlay will never update history.
.up-current now works in layers without history










Async functions no longer wait for animations
=============================================

In Unpoly 0.x async functions didn't settle until animation fnished.

Un Unpoly 1.0 Updates and removals settle as soon as the DOM was changed. Any animation will play out after settling.

This generally makes code more responsive:

    let user = await up.layer.ask({ url: '/users/new' })
    userSelect.value = user.id

If your code *does* need to wait:

    up.render({ url: '/foo', transition: true, onFinished: () => console.log("Transition has finished!") })

    up.destroy(element, { onFinished: () => console.log("Overlay has finished closing animation") })







up.request() is now a generic fetch() alternative ü•ã
====================================================

Many used `up.request()` for a cross-browser alternative to `$.ajax()` or `fetch()`, also to fetch JSON etc:

```js
let response = await up.request('/api/v3/json')
let json = JSON.parse(response.text)
```

But they also cache.

Direct calls to `up.fetch()` no longer cache by default.
They will with `{ cache: true }` (set by navigation intent)


Parsing JSON
------------

There is also up.Response#json

    let response = await up.request('/api/v3/foo)
    console.log(response.json)


Requests are abortable ü•ã
=========================

You may now abort requests:

    let request = up.request('/api/v3/foo)
    request.abort()

Emits a new event `up:layer:aborted`.

User navigation now aborts existing requests.


Cacheability may be fine-tuned ü•ã
=================================

Unpoly sends some additional HTTP headers to provide information about the fragment update:

| Request property               | Request header      |
| ------------------------------ | ------------------- |
| `up.Request#target`            | `X-Up-Target`       |
| `up.Request#failTarget`        | `X-Up-Fail-Target`  |
| `up.Request#context`     [NEW] | `X-Up-Context`      |
| `up.Request#failContext` [NEW] | `X-Up-Fail-Context` |
| `up.Request#mode`        [NEW] | `X-Up-Mode`         |
| `up.Request#failMode`    [NEW] | `X-Up-Fail-Mode`    |

The server may return an optimized response based on these properties,
e.g. by omitting a navigation bar that is not targeted.

 To **improve cacheability**, you may may set
`up.network.config.metaKeys` to a shorter list of property keys:

    // Server only optimizes for layer mode, but not for target selector
    up.network.config.metaKeys = ['mode']'

You may also send different request properties for different URLs:

```javascript
up.network.config.metaKeys = function(request) {
  if (request.url == '/search') {
    // The server optimizes responses on the /search route.
    return ['target', 'failTarget']
  } else {
    // The server doesn't optimize any other route,
    // so configure maximum cacheability.
    return []
  }
}
```





Navigation intent
=================

Learning: Not all fragment updates are user navigation.

There is a fundamental difference:

- User follows a link
- Updating a message count every 60 seconds

People tried to replace a box on the screen, but needed many option to disable scrolling, etc.

up.render(options) does not navigate by default. Use up.navigate(options) or up.render({ ...options, navigate: true }).

THE POINTS BELOW NO LONGER CORRECT!

E.g. when updating a message counter:

    up.render({ target: '.unread-count', navigate: true })

This will set multiple options:

| Setting           | Effect                                             |
| ----------------- | -------------------------------------------------- |
| `history: false`  | Don't update URL bar or document title             |
| `solo: false`     | Don't cancel existing requests                     |
| `reveal: false`   | Don't scroll to the new element                    |
| `peel: false`     | Don't close overlays when targeting a veiled layer |
| `feedback: false` | Don't set .up-active on the origin link            |
| `focus: false`    | Don't focus ater update                            |



| Setting          | Effect                                         |
| ---------------- | ---------------------------------------------- |
| `focus: 'auto'`  | Focus [autofocus] elements or new layers       |
| `scroll: 'auto'` | Reset scroll positions when updating [up-main] |
| `solo: true`     | Abort unfinished requests                      |
| `feedback: true` | Mark clicked links as .up-active while loading |
| `fallback: true` |                                                |


Configure with up.fragment.config.navigateOptions



User navigation aborts earlier requests
=======================================

Earlier Unpolys had a concurrency issue on slow connections:

- User clicks link #1
- Server takes long to respond to #1
- User clicks another link #2
- Server responds with #2
- Server responds with #1
- User sees effects of #1 (but expected to see effects of #2)

User navigation now aborts existing requests:

- User clicks link #1
- Server takes long to respond to #1
- User clicks another link #2
- Unpoly cancels request for #1
- Server responds with #2
- User sees effects of #2

You may disable this with `{ solo: false }` (JS) or `[up-solo="false"]` (HTML)


Smarter bandwidth usage
=======================

NO LONGER TRUE LIKE THIS

- User navigation aborts existing requests
- Preloading is now automatically disabled on slow connections
- Preload requests are aborted as the user leaves the area
- There is a single concurrency setting (default 4) for both regular requests and preload requests.
- Preload starts on mousedown and touchstart


Slow connection?
----------------

- User has data saving enabled ("Lite mode" in Chrome)
- RTT >= 750 ms (up.network.config.preloadMaxRTT)
- Downlink <= 600 Kbps (up.network.config.preloadMinDownlink)


Unified fragment update API
===========================

Unpoly 0.x had a number of functions for updating fragments.

Unpoly 1.0 has unified these into a single function `up.render()`:

    up.visit('/path')                  => up.render({ url: '/path' })
    up.modal.visit('/path')            => up.render({ url: '/path', layer: 'new' })
    up.replace('.element', '/path')    => up.render({ url: '/path', target: '.element' })
    up.extract('element', '<html>...') => up.render({ target: '.element', document: '<html>...' })

Every kind of fragment update accepts the full set of `render()`` options.

Use `up.navigate()` instead of `up.render()` if you're updating with a navigation intent.


Easy programmatic fragment changes
=================================

Open a layer without content:

```
up.layer.open()
```

Open a layer without target (will open in default target):

```
up.layer.open({ content: 'foo' })
```

Also works in HTML:

```html
<a up-layer="new" up-content="...">Help</a>
```



Change the inner content of an element:

```
up.render({ target: '.foo', content: 'New inner HTML' }
```

Derive target selector from new outer HTML:

```
// This will update .foo
up.render({ fragment: '<div class=".foo">inner</div>' })
```


Event handlers may change render() options
==========================================

When you interact with links or forms, Unpoly will emit these events:

- `up:link:follow`
- `up:link:preload` üéÅ
- `up:form:submit`
- `up:form:validate` üéÅ

Event handlers may prevent these events to cancel the fragment.

**Unpoly 1.x lets event listeners manipulate options for the upcoming `render()` call:**

```
up.on('up:form:submit', function(event) {
  event.renderOptions.failScroll = '.error-message'
  event.renderOptions.failTransition = 'shake'
})
```

If you have compilers that only set default attributes, consider using a single event listener that manipulates `event.renderOptions` instead. It's much leaner than a compiler, which needs to be called for every new fragment.


Pro example
-----------

Assume we give a new attribute `[authorize]` to links that require a signed-in user:

```html
<a href="/projects" authorize>My projects</a>
```

When clicking the link without a session, a login form should open in a modal overlay.
When the user has signed in successfully, the overlay closes and the original link is followed.

We can implement this with the following handler:

```js
up.on('up:link:follow', 'a[authorize]', async function(event) {
  if (!isSignedIn()) {
    event.preventDefault()
    await up.layer.ask('/session/new', { acceptLocation: '/welcome' })
    render(event.renderOptions)
  }
})
```





Tooltips are gone
=================

The tooltip component has been removed from Unpoly.

We want to focus on things that are hard to implement in userland.

There are countless alternatives:

- Bootstrap tooltips ([5.0 docs](https://v5.getbootstrap.com/docs/5.0/components/tooltips/), [4.5 docs](https://getbootstrap.com/docs/4.5/components/tooltips/))
- [Balloon.css](https://kazzkiq.github.io/balloon.css/) (CSS only)
- [Plain [title] attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title) (built into the browser)

Unpoly 1.0 will convert `[up-tooltip]` to `[title]`.


Tooltips don't work on mobile
-----------------------------

Touch devices [don't really have a "hover" state](https://makandracards.com/makandra/5117-touch-devices-don-t-have-mouseover-events).

That means that classic tooltips won't work on mobile. Consider a clickable popup instead:

```
<span up-layer="popup" up-content="Locking a user will prevent them from using the application">
  Help
</span>
```



Handling errors and maintenance pages ü•ã
========================================

A new event `up:fragment:loaded` is [emitted](/up.emit) when the server responds with the HTML, before the HTML is used to [change a fragment](/up.render).

Event listeners may call `event.preventDefault()` on an `up:fragment:loaded` event to prevent any changes to the DOM and browser history. This is useful to detect an entirely different page layout (like a maintenance page or fatal server error) which should be open with a full page load:

```js
up.on('up:fragment:loaded', (event) => {
  let isMaintenancePage = event.response.getHeader('X-Maintenance')

  if (isMaintenancePage) {
    // Prevent the fragment update and don't update browser history
    event.preventDefault()

    // Make a full page load for the same request.
    event.request.loadPage()
  }
})
```

There is also `up:fragment:unusable` in case the server responds with non-HTML content.



Accessibility
=============

Explain how important focus is to A11y.

up-nav sets [aria-current]

focus cycle in layers
focus returns after closing layer

focus controllable by user. List focus options!

| keep      |
| target    |
| layer     |
| autofocus |

| auto      | new layer    | autofocus, then layer
| auto      | update layer | keep,      then autofocus


 Explain default (autofocus, new layer, nothing)

Focus is preserved when updating a fragment that contains focus
  Cursor ("Caret")
  Selection range
  Scroll position


Already backported to 0.62:

- Links with an [`[up-instant]`](/a-up-instant) attribute can now be followed with the keyboard.
- Fragments that are being [destroyed](/up.destroy) now get an [`[aria-hidden=true]`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-hidden_attribute)
  attribute while its disappearance is being animated. When a fragment is being swapped with a new version, the old fragment version is also
  given `[aria-hidden=true]` while it's disappearing.
- [Modal dialogs](/up.modal) now get an [`[aria-modal=true]`](https://a11ysupport.io/tech/aria/aria-modal_attribute) attribute.



Boostrap integration
====================

Unpoly 1.0 now supports the three major Bootstrap versions we're using:

- unpoly-bootstrap3.js
- unpoly-bootstrap3.css
- unpoly-bootstrap4.js
- unpoly-bootstrap4.css
- unpoly-bootstrap5.js
- unpoly-bootstrap5.css

Integration is now minimal
--------------------------

Many projects didn't actually end up using the built-in Bootstrap integration, because it was too opinionated. E.g. Unpoly tried to re-use the Bootstrap modal styles, but most projects simply wanted the white box from the Unpoly default.

They ended up using their own configuration, which is much more minimal.

Unpoly 1.0 now ships with a **minimal Bootstrap integration**:

This is all of `unpoly-boostrap4.js`:

```js
// Bootstrap expects the class .active instead of .up-active
up.feedback.config.currentClasses.push('active')

// Set .up-current classes in Bootstrap navigation components
up.feedback.config.navs.push('.nav', '.navbar')

// When validating, update the closest form group with the results
up.form.config.validateTargets.unshift('.form-group:has(&)')

// When revealing, scroll far enough so content is not covered by
# fixed Bootstrap bars
up.viewport.config.fixedTop.push('.navbar.fixed-top')
up.viewport.config.fixedBottom.push('.navbar.fixed-bottom')
up.viewport.config.anchoredRight.push('.navbar.fixed-top', '.navbar.fixed-bottom')

// Don't use common utility classes to build selectors
up.fragment.config.badTargetClasses.push(
  'row',
  /^col(-xs|-sm|-md|-lg|-xl)?(-\d+)?$/,
  /^[mp][tblrxy]?-\d+$/
)
```

This is all of `unpoly-bootstrap4.scss`:

```css
// If a container is shown in an overlay, don't add to the existing
// padding of the overlay box.
up-modal, up-drawer, up-popup {
  .container, .container-fluid {
    padding-left: 0;
    padding-right: 0;
  }
}
```



Targets in components
=====================

**üí° We sometimes have multiple self-contained components on the same page. E.g. Deskbot cards.**

The position of a clicked link may now considered when deciding which element to replace.

In this example we have two links that replace `.card`:

    <div class="card" id="card1">
      Card #1 preview
      <a href="/cards/1" up-target=".card">Show full card #1</a>
    </div>

    <div class="card" id="card2">
      Card #2 preview
      <a href="/cards/2" up-target=".card">Show full card #2</a>
    </div>

When clicking "Sow full card #2", Unpoly 0.x would have replaced `.card`, matching the first card.

This makes it hard to use interactive components more than once in the same page.


Introducing :closest
--------------------

In Unpoly 1.0, links may refer to the closest ancestor with the experimental `:closest` pseudo class:

    <div class="card" id="card1">
      Card #1 preview
      <a href="/cards/1" up-target=".card:closest">Show full card #1</a>
    </div>

    <div class="card" id="card2">
      Card #2 preview
      <a href="/cards/2" up-target=".card:closest">Show full card #2</a>
    </div>

When clicking "Show full card #2", Unpoly 1.0 will replace `#card2` matching the second card.

While the card container still requires a unique selector (e.g. "id=card1"), none of the content elements do need to know about it.

This also works with descendant selectors:

    <div class="card" id="card1">
      <a href="/cards/1/links" up-target=".card:closest .card-links">Show card #2 links</a>
      <div class="card-links"></div>
    </div>

    <div class="card" id="card2">
      <a href="/cards/2/links" up-target=".card:closest .card-links">Show card #2 links</a>
      <div class="card-links"></div>
    </div>

When clicking "Show card#2 links", Unpoly 1.0 will replace `#card2 .card-links'.



Buggy compilers
===============

- When a compiler throws an error, other compilers will now run anyway. Errors will be logged.
- When a destructor throws an error, other destructors will now run anyway. Errors will be logged.


New log
=======

- Flat
- Function is highlighted at the beginning


up:click ü•ã
===========

Pain point: Userland code wants to handle `click`, but elements with [up-intant] activate on `mousedown`.

`up:click` is a `click` event that honors the [`[up-instant]`](/a-up-instant) attribute.

This event is generally emitted when an element is clicked. However, for elements
with an [`[up-instant]`](/a-up-instant) attribute this event is emitted on `mousedown` instead.

This is useful to listen to links being activated, without needing to know whether
a link is `[up-instant]`.

Example
-------

Assume we have two links, one of which is `[up-instant]`:

    <a href="/one">Link 1</a>
    <a href="/two" up-instant>Link 2</a>

The following event listener will be called when *either* link is activated:

    document.addEventListener('up:click', function(event) {
      ...
    })

Cancelation is forwarded
------------------------

If the user cancels an `up:click` event, the underlying `click` or `mousedown` will also be canceled.
The following cancelation methods will be forwarded:

- `event.stopPropagation()`
- `event.stopImmediatePropagation()`
- `event.preventDefault()

Accessibility
------------

If the user activates an element using their keyboard, the `up:click` event will be emitted
on `click`, even if the element has an `[up-instant]` attribute.



Unified scroll options
======================

All scroll-related options (`{ reveal, resetScroll, restoreScroll }`) have been reduced to a single option `{ scroll }`. It accepts one of the following values:

| Option value        | Effect                                     |
| ------------------- | ------------------------------------------ |
| `'target'`          | Reveal the updated fragment (0.x default)  |
| `'top'`             | Scroll to the top                          |
| `'restore'`         | Restore last known scroll position for URL |
| `'hash'`            | Scroll to a #hash in the updated URL       |
| `Function(options)` | Pass your own scrolling *logic             |
| `false`             | Don't scroll                               |
| `'auto'`            | *See below*                                |


Calmer scrolling
================

**üí° Unpoly 0.x scrolled too much.**

Unpoly 1.0 no longer scrolls by default.

Only when **navigating** the new default is `{ scroll: 'auto' }`, which *sometimes* scrolls:

- If the URL has a `#hash`, scroll to the hash.
- If updating a main target, scroll to the top.
- Else don't scroll. 



Tuning the scroll effect
========================

| Option               | Meaning                                       | Default                 |
| -------------------- | --------------------------------------------- | ----------------------- |
| `{ revealPadding }`  | Pixels between element and viewport edge      | `0`                     |
| `{ revealTop }`      | Whether to move a revealed element to the top | `false`                 |
| `{ revealMax }`      | How much of a high element to reveal          | `0.5 * innerHeight`     |
| `{ revealSnap }`     | When to snap to the top edge                  | `200`                   |
| `{ scrollBehavior }` | auto/smooth                                   | `'auto'` (no animation) |
| `{ scrollSpeed }`    | Acceleration of smooth scrolling              | `1` (mimic Chrome)      |



ü•ã Content Security Policy
==========================

By choosing a strict CSP, you also decide against using event handlers in your HTML.

Handlers like `[up-on-accepted]` cannot work with CSP:

```html
<a href="/contacts/new"
  up-layer="new"
  up-accept-location="/contacts/$id"
  up-on-accepted="up.reload('.table')">
  ...
</a>  
```

Move it to UJS:

```html
<a href="/contacts/new" class="add-contact" up-follow>...</a>
```

```js
up.on('up:link:follow', '.add-contact', function(event) {
  event.renderOptions.layer = 'new'
  event.renderOptions.acceptLocation = '/contacts/$id'
  event.renderOptions.onAccepted = (event) => { up.reload('.table') }
})
```


Polling
=======

**üí°Ô∏è Polling is a much-requested feature. Userland implementations often don't handle slow connections, failed requests or hidden browser tabs.**

Unpoly 1.0 ships with a polling implementation that handles edge cases.

This reloads the fragment every 30 seconds:

```html
<div class="unread-messages" up-poll>
  You have 2 unrread messages
</div>
```

You may set the poll frequency as the `[up-poll]` attribute value:

```html
<div class="unread-messages" up-poll="60_000">
  You have 2 unrread messages
</div>
```

Digit groups separators (`60_000`) are a stage 3 ES6 feature and also supported in number attributes.





Improved server integration
===========================

Examples for unpoly-rails (rack-unpoly etc. might follow.)


Emitting events
---------------

The server can emit events on the frontend:

    up.emit('user:selected', id: 5)
    up.layer.emit('user:selected', id: 5)

The events are emitted before fragments are updated.

Event handlers may close an overlay


Closing layers
--------------

The server can now close layers:

    up.layer.accept(id: 5)
    up.layer.dismiss()


Values survive redirect
------------------------


Detecting layer modes
---------------------

Server: Knows if a request targets an overlay

    up.layer.overlay?
    up.layer.root?


Clearing cache
--------------

Server can clear the cache:

    up.cache.clear

Useful e.g. for persisting queries.




Renamed package
---------------

The up.proxy package is now up.network.



New pseudo-classes for targets ü•ã
==============================

target: '.foo'
target: '.foo:has(.bar)'
target: ':main'
target: ':layer'
target: ':none'
target: '.foo:closest', origin: element
target: '.foo:closest .child', origin: element

