up.layer = do ->

  state = new up.Config ->
    stack: new up.layer.Stack(layers: [buildRootLayer()])
    queue: new up.TaskQueue()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "cancel XHR requests that want to update a destroyed layer"

  updateCurrent = (props) ->
    u.assign(currentLayer(), props)

  syncWindowWithCurrent = ->
    layer = currentLayer()
    if layer.history
      document.title = layer.title
      up.history.push(layer.url)

  firstElement = (selector) ->
    matches = e.all(currentLayer().element, selector)
    if state.stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches[0]

  throw "if we fallback to replace <body> or <html> we have also removed .up-layer what do we do?"
  throw "i think we need to force-close those upper layers, regardless of whether they are sticky or not. also don't emit events that would cause additional XHR requests. or maybe cancel all XHR requests linked to a destroyed layer?"

  reset = ->
    state.reset()

  bestPreflightTarget = (target, options) ->
    throw "implement me"
    # suche mÃ¼sste jetzt so gehen:
    # - target + fallbacks im aktuellen layer. wir suchen nie einfach so in anderen layern.
    # - layer kann mehrere alternativen haben (oder closest reicht ja vielleicht auch)
    # - target + fallbacks in root
    # extractIn = -> (layer, target, html, options) ->

  root = ->
    state.layers[0] ||= buildRootLayer()

  buildRootLayer = ->
    new up.layers.Root()

  openNew = (options) ->
    throw "implement me"

  currentLayer = ->
    state.stack.current()

  asap = (fn) ->
    state.queue.asap(fn)

  dismissCurrent = (reason) ->
    if nobodyPreventsDismissEvent(reason)
      asap ->
        currentLayer()?.close()
        emitLayerDismissed(reason)

  confirmCurrent = (value) ->
    if nobodyPreventsConfirmEvent(value)
      asap ->
        currentLayer()?.close()
        emitLayerConfirmed(value)

  forElement = (element) ->
    for layer in state.stack.all() by -1
      if layer.contains(element)
        return element

  swapElements = (step) ->

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> state.stack.root()
  all: -> state.stack.all()
  parent: -> state.stack.parent()
  ancestors: -> state.stack.ancestors()
  selfAndAncestors: -> state.stack.selfAndAncestors()
  current: currentLayer
  resolveName: resolveName
