up.layer = do ->

  config = new up.Config ->
    hash =
      flavor: 'dialog'
      targets: ['[up-layer-target]']
      all: up.layer.Base.config

    registerFlavor(up.layer.Root, hash)
    registerFlavor(up.layer.Dialog, hash)
    registerFlavor(up.layer.Popover, hash)
    registerFlavor(up.layer.Drawer, hash)
    registerFlavor(up.layer.Fullscreen, hash)

    return hash

  queue = new up.TaskQueue()
  stack = new up.layer.Stack(-> layers: [new up.layers.Root()])

  registerFlavor = (implementation, store = config) ->
    name = implementation.flavor or throw "Implementation must implement { flavor } class prop"
    # Since the layer class names are not public API, we make their static
    # config property accessible through up.layer.config. E.g. up.layer.config.dialog
    # is set to up.layer.Dialog.config.
    subConfig = implementation.config
    subConfig.implementation = implementation
    store[name] = subConfig

  defaultTargets = (options = {}) ->
    flavorImplementation(options).defaults().targets

  flavorImplementation = (options = {}) ->
    flavor = options.flavor ? config.flavor
    implementation = config[flavor].implementation or up.fail("Unknown layer flavor: #{flavor}")

  reset = ->
    config.reset(deep: true)
    stack.reset()
    queue.reset()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "maybe default to { history: false } for new layers"
  throw "make layer argument optional for all functions (it defaults to current)"
  throw "config a default { default }"
  throw "config a default { target }"
  throw "implement { dismissible } and"
  throw "implement [up-peel]"
  throw "allow size classes for bootstrap-like modal implementations; maybe we can support [up-target][up-class] to set a class on the new fragment"
  throw "implement focus trapping within a layer"
  throw "make sure .up-layer has [role=dialog]"
  throw "implement up:layer:* events"

  open = (options = {}) ->
    if options.content
      openWithContent(options)
    else
      # up.change() is a new function that takes these forms:
      # - up.change(target: ..., url: ...)
      # - up.change(target: ..., html: ...)
      # - up.change(html: ...)
      # - up.change(url: ...)
      # if we would offer { content } for up.change():
      # - we could only allow a single target (no ",", no hungries)
      throw "implement up.change()"
      up.change(options)

  openWithContent = (options) ->
    options = u.options(options)
    options.flavor ?= config.flavor

    if u.isString(options.content)
      options.content = e.createFromHtml(options.content)

    implementation = config[options.flavor].implementation

    # implementation constructor will take care of default options
    layer = new options.implementation(options)
    return layer.open(layersContainer(), content)

  prompt = (options) ->
    return new Promise (onConfirm, onDismiss) ->
      options = u.merge(options, { onConfirm, onDismiss, })
      open(options)

  throw "implement a[layer=new][up-on-confirm='code']"
  throw "implement a[layer=new][up-on-dismiss='code']"

  updateHistory = (layer, options) ->
    layer = lookup(layer)[0]

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  firstElement = (layer, selector) ->
    allElements(layer, selector)[0]

  allElements = (layer, selector) ->
    layer = lookup(layer)[0]
    matches = e.all(layer.containerElement, selector)
    if stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches

  layersContainer = ->
    selector = '.up-layers'
    e.first(selector) || e.affix(document.body, selector)

  currentLayer = ->
    stack.current()

  asap = (fn) ->
    queue.asap(fn)

  dismiss = (options = {}) ->
    options.layer = lookup(options.layer)

    eventProps =
      target: layer.element
      layer: layer
      reason: options.reason

    closeVariant
      layer: layer,
      eventProps: eventProps
      closeEvent: 'up:layer:dismiss'
      closedEvent: 'up:layer:dismissed'
      closedCallback: 'onDismissed'

  confirm = (options) ->
    options.layer = lookup(options.layer)

    eventProps =
      target: layer.element
      layer: layer
      reason: options.reason

    closeVariant
      layer: layer,
      eventProps: eventProps
      closeEvent: 'up:layer:confirm'
      closedEvent: 'up:layer:confirmed'
      closedCallback: 'onConfirmed'

  abortCompetingRequests = (options) ->
    layer = lookupOne(options)
    if layer == 'new'
      up.proxy.abort(preflightLayer: layer)

  closeVariant = (options) ->
    { layer, eventProps } = options

    # Abort all pending requests targeting the layer we're now closing.
    up.proxy.abort(preflightLayer: layer)

    if up.event.nobodyPrevents(options.closeEvent, eventProps)
      # Synchronously remove the layer from the stack so other sync calls
      # immediately see the updated stack. Everything after that is just optics.
      stack.remove(layer)

      return asap ->
        layer.close()
        # Wait for the callbacks until the closing animation ends,
        # so user-provided code doesn't run too wildly out of order.
        layer[options.closedCallback]?(eventProps)
        up.emit(options.closedEvent, eventProps)
    else
      return up.event.abortRejection()

  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  throw "Split into lookupAll and lookupOne"
  lookup = (value, options) ->
    unless value
      return [stack.root()]

    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())
      when 'new'
        'new'

  peel = (layer) ->
    layer = lookup(layer)[0]

    for ancestor in up.stack.ancestors() by -1
      asap ->
        # We only close, but don't emit events!
        ancestor.close()

    throw "cancel XHR requests that would update this layer"

    return queue.cursor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: lookup
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
  config: config
  defaultTargets: defaultTargets
