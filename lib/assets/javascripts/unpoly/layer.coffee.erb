up.layer = do ->

  state = new up.Config ->
    stack: new up.layer.Stack(layers: [buildRootLayer()])
    queue: new up.TaskQueue()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "cancel XHR requests that want to update a destroyed layer"
  throw "state.stack is really long to write"
  throw "maybe default to { history: false } for new layers"

  updateCurrent = (props) ->
    u.assign(currentLayer(), props)

  updateUrl = (layer, newUrl) ->
    layer.url = newUrl
    urlChanged(layer)

  updateTitle = (layer, title) ->
    titleChanged(layer)

  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  firstElement = (layer, selector) ->
    matches = e.all(layer.element, selector)
    if state.stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches[0]

  reset = ->
    state.reset()

  bestPreflightTarget = (target, options) ->
    throw "implement me"
    # suche mÃ¼sste jetzt so gehen:
    # - target + fallbacks im aktuellen layer. wir suchen nie einfach so in anderen layern.
    # - layer kann mehrere alternativen haben (oder closest reicht ja vielleicht auch)
    # - target + fallbacks in root
    # extractIn = -> (layer, target, html, options) ->

  root = ->
    state.layers[0] ||= buildRootLayer()

  buildRootLayer = ->
    new up.layers.Root()

  openNew = (options) ->
    throw "implement me"

  currentLayer = ->
    state.stack.current()

  asap = (fn) ->
    state.queue.asap(fn)

  dismissCurrent = (reason) ->
    if nobodyPreventsDismissEvent(reason)
      asap ->
        currentLayer()?.close()
        emitLayerDismissed(reason)

  confirmCurrent = (value) ->
    if nobodyPreventsConfirmEvent(value)
      asap ->
        currentLayer()?.close()
        emitLayerConfirmed(value)

  forElement = (element) ->
    for layer in state.stack.all() by -1
      if layer.contains(element)
        return element

  resolve = (value, options) ->
    if value instanceof up.Layer
      return [value]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [state.stack.root()]
      when 'origin'
        [givenOriginLayer()]
      when 'current'
        [currentLayer()]
      when 'parent'
        [state.stack.parent(givenOriginLayer())]
      when 'ancestors'
        state.stack.ancestors(givenOriginLayer())
      when 'closest'
        state.stack.selfAndAncestors(givenOriginLayer())
      when 'any'
        state.stack.all()

  dismiss = (layer) ->
    throw "dismiss layer"
    throw "cancel XHR requests that would update this layer"

  peel = (layer) ->
    for ancestor in up.stack.ancestors() by -1
      asap ->
        # We only close, but don't emit events!
        ancestor.close()
    return state.queue.cursor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> state.stack.root()
  all: -> state.stack.all()
  parent: -> state.stack.parent()
  ancestors: -> state.stack.ancestors()
  selfAndAncestors: -> state.stack.selfAndAncestors()
  current: currentLayer
  resolveName: resolveName
  firstElement: firstElement
  peel: peel
