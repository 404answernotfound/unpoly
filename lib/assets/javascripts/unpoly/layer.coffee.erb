up.layer = do ->

  config = new up.Config ->
    hash =
      flavor: 'window'
      targets: ['[up-layer-target]']
    u.merge(hash, up.layer.Base.defaultConfig())
    return hash

  flavors = new up.Config ->
    hash = {}
    registerFlavor('dialog', up.layer.Dialog, hash)
    registerFlavor('popover', up.layer.Popover, hash)
    registerFlavor('drawer', up.layer.Drawer, hash)
    registerFlavor('fullscreen', up.layer.Fullscreen, hash)
    return hash

  queue = new up.TaskQueue()
  stack = new up.layer.Stack(-> layers: [new up.layers.Root()])

  registerFlavor = (name, implementation, store = flavors) ->
    store[name] = u.merge(implementation.defaultConfig, { implementation })

  flavorOptions = (name, userOptions) ->
    u.merge(config, flavors[name], userOptions)

  reset = ->
    config.reset()
    stack.reset()
    queue.reset()
    flavors.reset()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "maybe default to { history: false } for new layers"
  throw "make layer argument optional for all functions (it defaults to current)"
  throw "config a default { default }"
  throw "config a default { target }"
  throw "implement { dismissible } and"
  throw "implement [up-peel]"
  throw "allow size classes for bootstrap-like modal implementations; maybe we can support [up-target][up-class] to set a class on the new fragment"
  throw "implement focus trapping within a layer"
  throw "make sure .up-layer has [role=dialog]"

  open = (options) ->
    options = u.options(options)
    options.flavor ?= config.flavor
    throw 'set default target by up.ExtractCascade, depending on the value of { layer }'
    # { layer: 'new' } will use the up.layer.config.targets,
    # while { layer: anything-else } will use up.link.config.targets.
    options.target ?= config.targets

    if options.content
      if u.isString(options.content)
        options.content = e.createFromHtml(options.innerHTML)
      openNow(options.flavor, options.content, options)
    else
      # up.change() is a new function that takes these forms:
      # - up.change(target: ..., url: ...)
      # - up.change(target: ..., html: ...)
      # - up.change(html: ...)
      # - up.change(url: ...)
      # if we would offer { content } for up.change():
      # - we could only allow a single target (no ",", no hungries)
      up.change(options)

  openNow = (flavor, content, options) ->
    options = flavorOptions(flavor, options)
    layer = new options.implementation(options)
    return layer.open(layersContainer)

  prompt = (options) ->
    return new Promise (onConfirm, onDismiss) ->
      options = u.merge(options, { onConfirm, onDismiss, })
      open(options)

  throw "implement a[layer=new][up-on-confirm='code']"
  throw "implement a[layer=new][up-on-dismiss='code']"

  updateHistory = (layer, options) ->
    layer = lookup(layer)[0]

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  firstElement = (layer, selector) ->
    allElements(layer, selector)[0]

  allElements = (layer, selector) ->
    layer = lookup(layer)[0]
    matches = e.all(layer.containerElement, selector)
    if stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches

  layersContainer = ->
    selector = '.up-layers'
    e.first(selector) || e.affix(document.body, selector)

  currentLayer = ->
    stack.current()

  asap = (fn) ->
    queue.asap(fn)

  dismiss = (options = {}) ->
    options.layer = lookup(options.layer)

    eventProps =
      target: layer.element
      layer: layer
      reason: options.reason

    closeVariant
      layer: layer,
      eventProps: eventProps
      closeEvent: 'up:layer:dismiss'
      closedEvent: 'up:layer:dismissed'
      closedCallback: 'onDismissed'

  confirm = (options) ->
    options.layer = lookup(options.layer)

    eventProps =
      target: layer.element
      layer: layer
      reason: options.reason

    closeVariant
      layer: layer,
      eventProps: eventProps
      closeEvent: 'up:layer:confirm'
      closedEvent: 'up:layer:confirmed'
      closedCallback: 'onConfirmed'

  closeVariant = (options) ->
    { layer, eventProps } = options

    up.proxy.abort(preflightLayer: layer)

    if up.event.nobodyPrevents(options.closeEvent, eventProps)
      # Synchronously remove the layer from the stack so other sync calls
      # immediately see the updated stack. Everything after that is just optics.
      stack.remove(layer)

      return asap ->
        layer.close()
        # Wait for the callbacks until the closing animation ends,
        # so user-provided code doesn't run too wildly out of order.
        layer[options.closedCallback]?(eventProps)
        up.emit(options.closedEvent, eventProps)
    else
      return up.event.abortRejection()

  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  throw "Split into lookupAll and lookupOne"
  lookup = (value, options) ->
    unless value
      return [stack.root()]

    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())

  peel = (layer) ->
    layer = lookup(layer)[0]

    for ancestor in up.stack.ancestors() by -1
      asap ->
        # We only close, but don't emit events!
        ancestor.close()

    throw "cancel XHR requests that would update this layer"

    return queue.cursor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: lookup
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
  config: config
  flavors: flavors

  throw "Deprecate up.modal.flavor() registration"
