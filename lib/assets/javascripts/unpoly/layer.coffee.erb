up.layer = do ->

  config = new up.Config ->
    dialog: 'window'
    targets: ['[up-layer-target]']
    history: true

  throw "API to register new dialog types"
  throw "allow users to config dialog types"

  queue = new up.TaskQueue()
  stack = new up.layer.Stack(-> layers: [new up.layers.Root()])

  reset = ->
    config.reset()
    stack.reset()
    queue.reset()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "cancel XHR requests that want to update a destroyed layer"
  throw "maybe default to { history: false } for new layers"
  throw "make layer argument optional for all functions (it defaults to current)"
  throw "config a default { default }"
  throw "config a default { target }"

  open = (options) ->
    options = u.options(options)
    options.dialog ?= config.dialog
    throw 'set default target by up.ExtractCascade, depending on the value of { layer }'
    # { layer: 'new' } will use the up.layer.config.targets,
    # while { layer: anything-else } will use up.link.config.targets.
    options.target ?= config.targets

    if options.content
      if u.isString(options.content)
        options.content = e.createFromHtml(options.innerHTML)
      throw "open now!"
    else
      # up.change() is a new function that takes these forms:
      # - up.change(target: ..., url: ...)
      # - up.change(target: ..., html: ...)
      # - up.change(html: ...)
      # - up.change(url: ...)
      # if we would offer { content } for up.change():
      # - we could only allow a single target (no ",", no hungries)
      up.change(options)

  updateHistory = (layer, options) ->
    layer = resolve(layer)[0]

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  firstElement = (layer, selector) ->
    allElements(layer, selector)[0]

  allElements = (layer, selector) ->
    layer = resolve(layer)[0]
    matches = e.all(layer.element, selector)
    if stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches

  currentLayer = ->
    stack.current()

  asap = (fn) ->
    queue.asap(fn)

  dismissCurrent = (reason) ->
    if nobodyPreventsDismissEvent(reason)
      asap ->
        currentLayer()?.close()
        callDismissCallbackOption(reason)
        emitLayerDismissed(reason)

    throw "cancel XHR requests that would update this layer"
    throw "error when dismissing root layer"


  confirmCurrent = (value) ->
    if nobodyPreventsConfirmEvent(value)
      asap ->
        currentLayer()?.close()
        callConfirmCallbackOption(reason)
        emitLayerConfirmed(value)

    throw "cancel XHR requests that would update this layer"
    throw "error when confirming root layer"


  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  resolve = (value, options) ->
    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())


  peel = (layer) ->
    layer = resolve(layer)[0]

    for ancestor in up.stack.ancestors() by -1
      asap ->
        # We only close, but don't emit events!
        ancestor.close()

    throw "cancel XHR requests that would update this layer"

    return queue.cursor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: resolve
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
