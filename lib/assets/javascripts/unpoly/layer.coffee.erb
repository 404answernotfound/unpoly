u = up.util
e = up.element

up.layer = do ->

  DEFAULT_IMPLEMENTATIONS = [
    up.Layer.Root
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]

  registerFlavor = (Implementation, store = config) ->
    flavor = Implementation.flavor
    store[flavor] ||= {}
    store[flavor].Implementation = Implementation

  # TODO: Document up.layer.config
  config = new up.Config ->
    newConfig =
      flavor: 'modal'
      resetWorld: true
      all:
        targets: []
      root:
        targets: ['body']
      overlay:
        targets: []
        position: null
        align: null
        size: null
        openAnimation: 'fade-in'
        closeAnimation: 'fade-out'
        openDuration: null
        closeDuration: null
        openEasing: null
        closeEasing: null
        backdropOpenAnimation: 'fade-in'
        backdropCloseAnimation: 'fade-out'
        dismissLabel: 'Ã—'
        dismissAriaLabel: 'Dismiss dialog'
        dismissable: true
      popup:
        position: 'bottom'
        align: 'left'
      drawer:
        position: 'left'
        openAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-from-left'
            when 'right' then 'move-from-right'
        closeAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-to-left'
            when 'right' then 'move-to-right'

    for implementation in DEFAULT_IMPLEMENTATIONS
      registerFlavor(implementation, newConfig)

    return newConfig

  stack = null

  handlers = []

  isOverlayFlavor = (name) ->
    name != 'root' && name != 'overlay' && !!config[name]

#  flavorFromOptions = (options) ->
#    options.flavor ? config.flavor

  defaultTargets = (flavor) ->
    return u.flatMap flavorConfigs(flavor), 'targets'

  ###**
  Returns an array of config objects that apply to the given flavor name.

  The config objects are in descending order of specificity.
  ###
  flavorConfigs = (flavor = config.flavor) ->
    if flavor == 'root'
      return [config.root, config.all]
    else
      return [config[flavor], config.overlay, config.all]

  build = (options) ->
    console.debug("--- build start with options %o", u.copy(options))
    flavor = options.flavor ? config.flavor
    Implementation = config[flavor].Implementation
    configs = u.reverse(flavorConfigs(flavor))
    options = u.mergeDefined(configs..., { flavor, stack }, options)
    console.debug("--- new with options %o", u.copy(options))
    return new Implementation(options)

#  flavorImplementation = (options = {}) ->
#    flavor = options.flavor ? config.flavor
#    config[flavor].Implementation or up.fail("Unknown layer flavor: #{flavor}")

  openCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      new Function('event', code).bind(link)

  closeCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Allow callbacks to refer to `value` directly instead of through `event.value`.
      callback = new Function('event', 'value', code)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      return (event) -> callback.call(link, event, event.value)

  reset = ->
    config.reset()
    stack.reset()
    handlers = u.filter(handlers, 'isDefault')

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    return up.change(options)

  # TODO: Docs for up.layer.ask()
  ask = (options) ->
    return new Promise (resolve, reject) ->
      options = u.merge options,
        onAccepted: (event) -> resolve(event.value)
        onRejected: (event) -> reject(event.value)
      open(options)

  allElements = (selector, options) ->
    layers = stack.lookupAll(options)
    u.flatMap layers, (layer) -> layer.allElements(selector)

  firstElement = (selector, options) ->
    layers = stack.lookupAll(options)
    u.findResult layers, -> layer.firstElement(selector)

  # Event handlers for [up-target] etc. are registered to each layer instead of
  # only once to the document. See https://github.com/unpoly/unpoly/issues/79
  registerHandler = (handler...) ->
    handler.isDefault = up.framework.isBooting()
    handlers.push(handler)
    for layer in stack.layers
      layer.on(handler...)

  applyHandlers = (layer) ->
    for handler in handlers
      console.debug("applyHandler: %o, %o", layer, handler)
      layer.on(handler...)

  up.event.onEscape (event) ->
    layer = stack.current
    if layer.dismissable
      u.muteRejection layer.dismiss()
      up.event.halt(event)

  up.on 'up:framework:boot', ->
    # TODO: Docs for [up-modal]
    # TODO: Docs for [up-popup]
    # TODO: Docs for [up-drawer]
    # TODO: Docs for [up-cover]
    for implementation in DEFAULT_IMPLEMENTATIONS
      if attr = implementation.attr
        up.link.targetMacro attr,
          'up-layer': implementation.flavor

  registerCloseHandler = (attribute, closeFn) ->
    # Allow the fallbacks to be both vanilla links and Unpoly [up-target] links
    registerHandler 'click up:link:follow', "[#{attribute}]", (event) ->
      origin = event.target
      layer = stack.of(origin)
      # To make a view usable both as a root layer and as an overlay, the programmer might
      # define a fallback like this:
      #
      #     <a href="/fallback" up-accept>...</a>
      #
      # We only want to accept the layer (and halt the event chain) if that link is in an overlay.
      # If the link is in the root layer, we allow the event to bubble up.
      unless layer.isRoot()
        value = e.jsonAttr(origin, attribute)
        # u.muteRejection closeFn(layer, { value, origin })
        closeFn(layer, { value, origin })
        up.event.halt(event)

  up.on 'up:framework:boot', ->
    stack = new up.LayerStack()

    registerCloseHandler 'up-accept', (layer, closeOptions) ->
      return layer.accept(closeOptions)

    registerCloseHandler 'up-dismiss', (layer, closeOptions) ->
      return layer.dismiss(closeOptions)

    registerCloseHandler 'up-close', (layer, closeOptions) ->
      up.legacy.deprecated('[up-close]', '[up-dismiss]')
      return layer.dismiss(closeOptions)

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  u.literal
    of: (args...) -> stack.of(args...)
    lookup: (args...) -> stack.lookupOne(args...)
    lookupAll: (args...) -> stack.lookupAll(args...)
    get_overlayContainer: -> stack.overlayContainer
    attachOverlayContainer: -> stack.attachOverlayContainer()
    allElements: allElements
    firstElement: firstElement
    config: config
    defaultTargets: defaultTargets
    open: open
    build: build
    accept: (args...) -> stack.current.accept(args...)
    dismiss: (args...) -> stack.current.dismiss(args...)
    sync: (args...) -> stack.current.sync(args...)
    openCallbackAttr: openCallbackAttr
    closeCallbackAttr: closeCallbackAttr
    isRoot: -> stack.isRoot()
    push: (args...) -> stack.push(args...)
    flavor: registerFlavor
    isOverlayFlavor: isOverlayFlavor
    on: (args...) -> stack.current.on(args...)
    off: (args...) -> stack.current.off(args...)
    emit: (args...) -> stack.current.emit(args...)
    onEach: registerHandler
    applyHandlers: applyHandlers
    get_root: -> stack.root
    get_all: -> stack.layers
    get_current: -> stack.current
    get_leaf: -> stack.leaf
    get_parent: -> stack.parent
    parentOf: (args...) -> stack.parentOf(args...)
    get_location: -> stack.current.location
    get_flavor: -> stack.current.flavor
    get_position: -> stack.current.position
    get_element: -> stack.current.element
    get_context: -> stack.current.context
    contains: (args...) -> stack.current.contains(args...)

# TODO: Docs for up.context
u.getter(up, 'context', -> up.layer.context)
