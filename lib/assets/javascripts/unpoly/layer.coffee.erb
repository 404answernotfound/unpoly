u = up.util

up.layer = do ->

  DEFAULT_IMPLEMENTATIONS = [
    up.Layer.Root
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]

  registerFlavor = (Implementation, store = config) ->
    flavor = Implementation.flavor
    store[flavor] ||= {}
    store[flavor].Implementation = Implementation

  config = new up.Config ->
    newConfig =
      flavor: 'modal'
      resetWorld: true
      all:
        targets: []
      root:
        targets: ['body']
      overlay:
        targets: []
        position: null
        align: null
        size: null
        openAnimation: 'fade-in'
        closeAnimation: 'fade-out'
        openDuration: null
        closeDuration: null
        openEasing: null
        closeEasing: null
        backdropOpenAnimation: 'fade-in'
        backdropCloseAnimation: 'fade-out'
        dismissLabel: 'Ã—'
        dismissAriaLabel: 'Dismiss dialog'
        dismissible: true
      popup:
        position: 'bottom'
        align: 'left'
      drawer:
        position: 'left'
        openAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-from-left'
            when 'right' then 'move-from-right'
        closeAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-to-left'
            when 'right' then 'move-to-right'

    for implementation in DEFAULT_IMPLEMENTATIONS
      registerFlavor(implementation, newConfig)

    return newConfig

  stack = null

  initStack = ->
    console.debug("Init stack start")
    stack = new up.LayerStack()
    console.debug("Init stack done")

  isOverlayFlavor = (name) ->
    name != 'root' && name != 'page' && !!config[name]

#  flavorFromOptions = (options) ->
#    options.flavor ? config.flavor

  defaultTargets = (flavor) ->
    return u.flatMap flavorConfigs(flavor), (prop) -> config[prop].targets

  ###**
  Returns an array of config objects that apply to the given flavor name.

  The config objects are in descending order of specificity.
  ###
  flavorConfigs = (flavor = config.flavor) ->
    if flavor == 'root'
      return ['root', 'all']
    else
      return [flavor, 'overlay', 'all']

  build = (options) ->
    flavor = options.flavor ? config.flavor
    Implementation = config[flavor].Implementation
    configs = u.reverse(flavorConfigs(flavor))
    options = u.merge(configs..., { flavor, stack }, options)
    console.debug("building with", { options })
    return new Implementation(options)

#  flavorImplementation = (options = {}) ->
#    flavor = options.flavor ? config.flavor
#    config[flavor].Implementation or up.fail("Unknown layer flavor: #{flavor}")

  openCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      new Function('event', code).bind(link)

  closeCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Allow callbacks to refer to `value` directly instead of through `event.value`.
      callback = new Function('event', 'value', code)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      return (event) -> callback.call(link, event, event.value)

  reset = ->
    config.reset()
    stack.reset()

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    up.change(options)


  # TODO: Docs for up.layer.ask()
  ask = (options) ->
    return new Promise (resolve, reject) ->
      options = u.merge options,
        onAccepted: (event) -> resolve(event.value)
        onRejected: (event) -> reject(event.value)
      open(options)

  allElements = (selector, options) ->
    layers = stack.lookupAll(options)
    u.flatMap layers, (layer) -> layer.allElements(selector)

  firstElement = (selector, options) ->
    layers = stack.lookupAll(options)
    u.findResult layers, -> layer.firstElement(selector)

  up.event.onEscape (event) ->
    if stack.current.dismissable
      u.muteRejection dismiss()
      up.event.halt(event)

  # TODO: Docs for [up-modal]
  # TODO: Docs for [up-popup]
  # TODO: Docs for [up-drawer]
  # TODO: Docs for [up-cover]
  for implementation in DEFAULT_IMPLEMENTATIONS
    if attr = implementation.attr
      up.link.targetMacro attr,
        'up-layer': implementation.flavor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  u.literal
    forElement: (args...) -> stack.forElement(args...)
    lookup: (args...) -> stack.lookupOne(args...)
    lookupAll: (args...) -> stack.lookupAll(args...)
    get_overlayContainer: -> stack.overlayContainer
    attachOverlayContainer: -> stack.attachOverlayContainer()
    allElements: allElements
    firstElement: firstElement
    config: config
    defaultTargets: defaultTargets
    open: open
    build: build
    accept: (args...) -> stack.current.accept(args...)
    dismiss: (args...) -> stack.current.dismiss(args...)
    sync: (args...) -> stack.current.sync(args...)
    openCallbackAttr: openCallbackAttr
    closeCallbackAttr: closeCallbackAttr
    isRoot: -> stack.isRoot()
    push: (args...) -> stack.push(args...)
    flavor: registerFlavor
    isOverlayFlavor: isOverlayFlavor
    on: (args...) -> stack.current.on(args...)
    off: (args...) -> stack.current.off(args...)
    emit: (args...) -> stack.current.emit(args...)
    get_root: -> stack.root
    get_all: -> stack.layers
    get_current: -> stack.current
    get_parent: -> stack.parent(current)
    get_location: -> stack.current.location
    get_flavor: -> stack.current.flavor
    get_position: -> stack.current.position
    get_element: -> stack.current.element
    get_context: -> stack.current.context
    contains: (args...) -> stack.current.contains(args...)
    initStack: initStack

# TODO: Docs for up.context
u.getter(up, 'context', -> up.layer.context)

# We need to run this after up.layer is defined.
up.layer.initStack()
