up.layer = do ->

  DEFAULT_FLAVOR_IMPLEMENTATIONS = [
    up.Layer.Root
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]

  config = new up.Config ->
    newConfig =
      flavor: 'modal'
      targets: ['[up-layer-target]']
      all: up.layer.Base.config

    for implementation in DEFAULT_FLAVOR_IMPLEMENTATIONS
      registerFlavor(implementation, newConfig)

    return newConfig

  stack = new up.LayerStack(-> layers: [new up.layers.Root()])

  registerFlavor = (implementation, store = config) ->
    name = implementation.flavor
    # Since the layer class names are not public API, we make their static
    # config property accessible through up.layer.config. E.g. up.layer.config.dialog
    # is set to up.layer.Dialog.config.
    subConfig = implementation.config
    subConfig.implementation = implementation
    store[name] = subConfig

  defaultTargets = (options = {}) ->
    flavorImplementation(options).defaults().targets

  flavorImplementation = (options = {}) ->
    flavor = options.flavor ? config.flavor
    implementation = config[flavor].implementation or up.fail("Unknown layer flavor: #{flavor}")

  closeHandlerAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      return new Function('value', code).bind(link)

  reset = ->
    config.reset(deep: true)
    stack.reset()
    queue.reset()

  open = (options = {}) ->
    if options.content
      openWithContent(options)
    else
      # up.change() is a new function that takes these forms:
      # - up.change(target: ..., url: ...)
      # - up.change(target: ..., html: ...)
      # - up.change(html: ...)
      # - up.change(url: ...)
      # if we would offer { content } for up.change():
      # - we could only allow a single target (no ",", no hungries)
      # - would also enable up.reload(Element)
      throw "implement up.change()"
      up.change(options)

  openWithContent = (options) ->
    options = u.options(options)
    options.flavor ?= config.flavor

    if u.isString(options.content)
      options.content = e.createFromHtml(options.content)

    implementation = config[options.flavor].implementation

    throw "implement up:layer:open event in up.Layer"

    # implementation constructor will take care of default options
    layer = new options.implementation(options)
    return layer.open(layersContainer(), content)

  prompt = (options) ->
    return new Promise (onConfirm, onDismiss) ->
      options = u.merge(options, { onConfirm, onDismiss, })
      open(options)

  throw "move to up.Layer.Base"
  updateHistory = (layer, options) ->
    layer = lookupOne(layer, options)

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  throw "move to up.Layer.Base"
  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  throw "move to up.Layer.Base"
  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  sync = (options) ->
    lookupOne(options).sync()

  dismiss = (options) ->
    lookupOne(options).dismiss(options)

  confirm = (options) ->
    lookupOne(options).confirm(options)

  layersContainer = ->
    selector = '.up-layers'
    e.first(selector) || e.affix(document.body, selector)

  currentLayer = ->
    stack.current()

  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  lookupOne = (options) ->
    lookupAll(options)[0]

  lookupAll = (options) ->
    value = options.value

    unless value
      return [stack.root()]

    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())

  peel = (layer) ->
    layer = lookup(layer)[0]
    ancestors = u.copy(up.stack.ancestors(layer))

    for ancestor in ancestors by -1
      asap ->
        dismiss(layer: ancestor, emitEvents: false)

    return queue.cursor

  up.event.onEscape (event) ->
    if currentLayer().dismissable
      u.muteRejection dismiss()
      up.event.halt(event)

  # TODO: Docs for [up-modal]
  # TODO: Docs for [up-popup]
  # TODO: Docs for [up-drawer]
  # TODO: Docs for [up-cover]
  for implementation in DEFAULT_FLAVOR_IMPLEMENTATIONS
    if attr = implementation.attr
      up.link.targetMacro attr,
        'up-layer': 'new'
        'up-flavor': implementation.flavor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: lookup
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
  sync: sync
  config: config
  defaultTargets: defaultTargets
