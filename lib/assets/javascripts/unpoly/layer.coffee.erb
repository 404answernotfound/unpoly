up.layer = do ->

  config = new up.Config ->
    hash =
      flavor: 'modal'
      targets: ['[up-layer-target]']
      all: up.layer.Base.config

    registerFlavor(up.layer.Root, hash)
    registerFlavor(up.layer.Modal, hash)
    registerFlavor(up.layer.Popup, hash)
    registerFlavor(up.layer.Drawer, hash)
    registerFlavor(up.layer.Fullscreen, hash)

    return hash

  queue = new up.TaskQueue()
  stack = new up.layer.Stack(-> layers: [new up.layers.Root()])

  registerFlavor = (implementation, store = config) ->
    name = implementation.flavor or throw "Implementation must implement { flavor } class prop"
    # Since the layer class names are not public API, we make their static
    # config property accessible through up.layer.config. E.g. up.layer.config.dialog
    # is set to up.layer.Dialog.config.
    subConfig = implementation.config
    subConfig.implementation = implementation
    store[name] = subConfig

  defaultTargets = (options = {}) ->
    flavorImplementation(options).defaults().targets

  flavorImplementation = (options = {}) ->
    flavor = options.flavor ? config.flavor
    implementation = config[flavor].implementation or up.fail("Unknown layer flavor: #{flavor}")

  closeHandlerAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      return new Function('value', code).bind(link)

  reset = ->
    config.reset(deep: true)
    stack.reset()
    queue.reset()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "allow size classes for bootstrap-like modal implementations; maybe we can support [up-target][up-class] to set a class on the new fragment"
  throw "implement focus trapping within a layer"
  throw "make sure .up-layer has [role=dialog]"
  throw "implement up:layer:* events"

  open = (options = {}) ->
    if options.content
      openWithContent(options)
    else
      # up.change() is a new function that takes these forms:
      # - up.change(target: ..., url: ...)
      # - up.change(target: ..., html: ...)
      # - up.change(html: ...)
      # - up.change(url: ...)
      # if we would offer { content } for up.change():
      # - we could only allow a single target (no ",", no hungries)
      throw "implement up.change()"
      up.change(options)

  openWithContent = (options) ->
    options = u.options(options)
    options.flavor ?= config.flavor

    if u.isString(options.content)
      options.content = e.createFromHtml(options.content)

    implementation = config[options.flavor].implementation

    # implementation constructor will take care of default options
    layer = new options.implementation(options)
    return layer.open(layersContainer(), content)

  prompt = (options) ->
    return new Promise (onConfirm, onDismiss) ->
      options = u.merge(options, { onConfirm, onDismiss, })
      open(options)

  throw "move to up.Layer.Base"
  updateHistory = (layer, options) ->
    layer = lookupOne(layer, options)

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  throw "move to up.Layer.Base"
  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  throw "move to up.Layer.Base"
  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  throw "move to up.Layer.Base"
  firstElement = (layer, selector) ->
    allElements(layer, selector)[0]

  throw "move to up.Layer.Base"
  sync = () ->
    # todo

  throw "move to up.Layer.Base"
  allElements = (layer, selector) ->
    layer = lookupOne(layer)
    matches = e.all(layer.containerElement, selector)
    if stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches

  layersContainer = ->
    selector = '.up-layers'
    e.first(selector) || e.affix(document.body, selector)

  currentLayer = ->
    stack.current()

  asap = (fn) ->
    queue.asap(fn)

  throw "move to up.Layer.Base"
  dismiss = (options) ->
    closeVariant(u.merge(options,
      valueAttr: 'up-dismiss'
      closeEvent: 'up:layer:dismiss'
      closedEvent: 'up:layer:dismissed'
      closedCallback: 'onDismissed'
    ))

  throw "move to up.Layer.Base"
  confirm = (options) ->
    closeVariant(u.merge(options,
      valueAttr: 'up-confirm'
      closeEvent: 'up:layer:confirm'
      closedEvent: 'up:layer:confirmed'
      closedCallback: 'onConfirmed'
    ))

  throw "move to up.Layer.Base"
  closeVariant = (options) ->
    layer = lookupOne(options.layer, options)
    origin = options.origin
    emitEvents = options.emitEvents ? true

    if origin
      options.value ?= e.jsonAttr(origin, options.valueAttr)

    eventProps =
      target: layer.element
      layer: layer
      value: options.value
      origin: origin

    # Abort all pending requests targeting the layer we're now closing.
    up.proxy.abort(preflightLayer: layer)

    if !emitEvents || up.event.nobodyPrevents(options.closeEvent, eventProps)
      # Synchronously remove the layer from the stack so other sync calls
      # immediately see the updated stack. Everything after that is just optics.
      stack.remove(layer)

      return asap ->
        layer.close().then ->
          if emitEvents
            # Wait for the callbacks until the closing animation ends,
            # so user-provided code doesn't run too wildly out of order.

            if closedCallback = layer[options.closedCallback]
              # Callback option only gets the resolution value.
              # Also see up.layer.closeHandlerAttr()
              closedCallback.call(origin, options.value)

            # Global event gets the full event props
            up.emit(options.closedEvent, eventProps)
    else
      return up.event.abortRejection()

  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  lookupOne = (options) ->
    lookupAll(options)[0]

  lookupAll = (options) ->
    value = options.value

    unless value
      return [stack.root()]

    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())

  peel = (layer) ->
    layer = lookup(layer)[0]
    ancestors = u.copy(up.stack.ancestors(layer))

    for ancestor in ancestors by -1
      asap ->
        dismiss(layer: ancestor, emitEvents: false)

    return queue.cursor

  up.event.onEscape (event) ->
    if currentLayer().dismissable
      u.muteRejection dismiss()
      up.event.halt(event)

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: lookup
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
  sync: sync
  config: config
  defaultTargets: defaultTargets
