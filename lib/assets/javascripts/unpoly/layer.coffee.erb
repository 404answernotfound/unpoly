up.layer = do ->

  DEFAULT_IMPLEMENTATIONS = [
    up.Layer.Root
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]

  config = new up.Config ->
    newConfig =
      flavor: 'modal'
      all: up.layer.Base.config

    for implementation in DEFAULT_IMPLEMENTATIONS
      registerFlavor(implementation, newConfig)

    return newConfig

  stack = new up.LayerStack(-> layers: [new up.Layer.Root()])

  registerFlavor = (Implementation, store = config) ->
    name = Implementation.flavor
    # Since the layer class names are not public API, we make their static
    # config property accessible through up.layer.config. E.g.
    # up.layer.config.dialog = up.layer.Dialog.config.
    subConfig = Implementation.config
    subConfig.Implementation = Implementation
    store[name] = subConfig

  defaultTargets = (options = {}) ->
    flavorImplementation(options).defaults().targets

  flavorImplementation = (options = {}) ->
    flavor = options.flavor ? config.flavor
    config[flavor].Implementation or up.fail("Unknown layer flavor: #{flavor}")

  closeHandlerAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      return new Function('value', 'event', code).bind(link)

  reset = ->
    config.reset(deep: true)
    stack.reset()

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    up.change(options)

  build = (options) ->
    flavor = options.flavor ? config.flavor
    Implementation = config[flavor].Implementation
    return new Implementation(stack, options)

  # TODO: Docs for up.layer.prompt()
  prompt = (options) ->
    return new Promise (onAccept, onDismiss) ->
      options = u.merge(options, { onAccept, onDismiss })
      open(options)

  allElements = (selector, options) ->
    layers = @stack.lookupAll(options)
    u.flatMap layers, (layer) -> layer.allElements(selector)

  firstElement = (selector, options) ->
    layers = @stack.lookupAll(options)
    u.findResult layers, -> layer.firstElement(selector)

  accept = (args...) ->
    @stack.asap =>
      @stack.current.accept(args...)

  dismiss = (args...) ->
    @stack.asap =>
      @stack.current.dismiss(args...)

  up.event.onEscape (event) ->
    if stack.current.dismissable
      u.muteRejection dismiss()
      up.event.halt(event)

  # TODO: Docs for [up-modal]
  # TODO: Docs for [up-popup]
  # TODO: Docs for [up-drawer]
  # TODO: Docs for [up-cover]
  for implementation in DEFAULT_IMPLEMENTATIONS
    if attr = implementation.attr
      up.link.targetMacro attr,
        'up-layer': 'new'
        'up-flavor': implementation.flavor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  u.literal
    forElement: (args...) -> stack.forElement(args...)
    lookup: (args...) -> stack.lookupOne(args...)
    lookupAll: (args...) -> stack.lookupAll(args...)
    get_container: -> stack.container
    attachContainer: -> stack.attachContainer()
    allElements: allElements
    firstElement: firstElement
    config: config
    defaultTargets: defaultTargets
    open: open
    build: build
    accept: (args...) -> stack.current.accept(args...)
    dismiss: (args...) -> stack.current.dismiss(args...)
    sync: (args...) -> stack.current.sync(args...)
    closeHandlerAttr: closeHandlerAttr
    isRoot: -> stack.isRoot()
    push: (args...) -> stack.push(args...)
    asap: (args...) -> stack.asap(args...)
    get_root: -> stack.root
    get_all: -> stack.all
    get_current: -> stack.current
    get_location: -> stack.current.location
    get_position: -> stack.current.position
    get_element: -> stack.current.element
    get_context: -> stack.current.context
    contains: (args...) -> stack.current.contains(args...)

# TODO: Docs for up.context
u.getter(up, 'context', -> up.layer.context)
