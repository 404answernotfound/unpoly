up.layer = do ->

  state = new up.Config ->
    layers: [buildRootLayer()]
    queue: new up.TaskQueue()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"

  updateCurrent = (props) ->
    u.assign(currentLayer(), props)

  syncWindowWithCurrent = ->
    layer = currentLayer()
    if layer.history
      document.title = layer.title
      up.history.push(layer.url)

  firstElement = (selector) ->
    matches = e.all(currentLayer().element, selector)
    if isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches[0]

  throw "if we fallback to replace <body> or <html> we have also removed .up-layer what do we do?"
  throw "i think we need to force-close those upper layers, regardless of whether they are sticky or not. also don't emit events that would cause additional XHR requests."

  isCurrentRoot = ->
    state.layers.length == 1

  reset = ->
    state.reset()

  bestPreflightSelector = (target, options) ->
    throw "implement me"
    # suche mÃ¼sste jetzt so gehen:
    # - target + fallbacks im aktuellen layer. wir suchen nie einfach so in anderen layern.
    # - layer kann mehrere alternativen haben (oder closest reicht ja vielleicht auch)
    # - target + fallbacks in root
    # extractIn = -> (layer, target, html, options) ->

  resolveName = (name, origin) ->
    originLayer = forElement(origin)

    switch name
      when 'root'
        [root()]
      when 'last'
        [currentLayer()]
      when 'origin'
        [originLayer]
      when 'parent'
        [ancestorLayers(originLayer)[0]]
      when 'ancestors'
        ancestorLayers(originLayer)
      when 'closest'
        [originLayer, ancestorLayers(originLayer)...]
      else
        throw new Error("Unknown { layer } option: #{name}")

  root = ->
    state.layers[0] ||= buildRootLayer()

  buildRootLayer = ->
    new up.layers.Root()

  openNew = (options) ->
    throw "implement me"

  currentLayer = ->
    u.last(state.layers)

  ancestorLayers = (layer) ->
    layerIndex = state.layers.indexOf(layer)
    state.layers.slice(0, layerIndex)

  parentLayer = (layer) ->
    layerIndex = state.layers.indexOf(layer)
    parentIndex = Math.max(layerIndex - 1, 0)
    state.layers[parentIndex]

  asap = (fn) ->
    state.queue.asap(fn)

  dismissLast = ->
    if nobodyPreventsDismissEvent()
      asap ->
        currentLayer()?.close()
        emitLayerDismissed()

  confirmLast = ->
    if nobodyPreventsConfirmEvent()
      asap ->
        currentLayer()?.close()
        emitLayerConfirmed()

  forElement = (element) ->
    for layer in state.layers by -1
      if layer.contains(element)
        return element

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  all: -> state.layers
  current: currentLayer
  resolveName: resolveName

