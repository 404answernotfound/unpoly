up.layer = do ->

  config = new up.Config(-> {})
  flavors = new up.Config(-> {})
  stack = new up.layer.Stack(-> layers: [new up.layers.Root()])
  queue = new up.TaskQueue()

  reset = ->
    config.reset()
    flavors.reset()
    stack.reset()
    queue.reset()

  throw "each update needs to update title and url in the current fragemnt"
  throw "only if the topmost layer is changed we change document.title or pushState(url)"
  throw "cancel XHR requests that want to update a destroyed layer"
  throw "maybe default to { history: false } for new layers"

  updateHistory = (layer, options) ->
    layer = resolve(layer)[0]

    if newUrl = options.history
      layer.url = newUrl
      urlChanged(layer)

    if newTitle = options.title
      layer.title = title
      titleChanged(layer)

  urlChanged = (layer) ->
    if layer == currentLayer() && layer.history
      up.history.push(layer.url)

  titleChanged = (layer) ->
    if layer == currentLayer() && layer.history # history option also says if we're updating title
      document.title = layer.title

  firstElement = (layer, selector) ->
    allElements(layer, selector)[0]

  allElements = (layer, selector) ->
    layer = resolve(layer)[0]
    matches = e.all(layer.element, selector)
    if stack.isCurrentRoot()
      matches = u.reject(matches, (match) -> e.closest(match, '.up-layer'))
    matches

  openNew = (options) ->
    throw "implement me"

  currentLayer = ->
    stack.current()

  asap = (fn) ->
    queue.asap(fn)

  dismissCurrent = (reason) ->
    if nobodyPreventsDismissEvent(reason)
      asap ->
        currentLayer()?.close()
        emitLayerDismissed(reason)

  confirmCurrent = (value) ->
    if nobodyPreventsConfirmEvent(value)
      asap ->
        currentLayer()?.close()
        emitLayerConfirmed(value)

  forElement = (element) ->
    element = e.get(element)

    for layer in stack.all() by -1
      if layer.contains(element)
        return element

  resolve = (value, options) ->
    if value instanceof up.Layer
      return [value]

    if u.isElement(value) || u.isJQuery(value)
      return [forElement(value)]

    givenOriginLayer = ->
      if origin = options.origin
        forElement(origin)
      else
        up.fail('Updating layer %s requires { origin } option', value)

    return switch value
      when 'root'
        [stack.root()]
      when 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        [stack.root()]
      when 'current'
        [currentLayer()]
      when 'any'
        u.reverse(stack.all())
      when 'origin'
        [givenOriginLayer()]
      when 'parent'
        [stack.parent(givenOriginLayer())]
      when 'ancestors'
        stack.ancestors(givenOriginLayer())
      when 'closest'
        stack.selfAndAncestors(givenOriginLayer())

  confirm = (layer, value) ->
    layer = resolve(layer)[0]

    throw "confirm layer"
    throw "call confirm listeners"
    throw "cancel XHR requests that would update this layer"
    throw "error when confirming root layer"

  dismiss = (layer, reason) ->
    layer = resolve(layer)[0]

    throw "dismiss layer"
    throw "call dismiss listeners"
    throw "cancel XHR requests that would update this layer"
    throw "error when dismissing root layer"

  peel = (layer) ->
    layer = resolve(layer)[0]

    for ancestor in up.stack.ancestors() by -1
      asap ->
        # We only close, but don't emit events!
        ancestor.close()

    throw "cancel XHR requests that would update this layer"

    return queue.cursor

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  root: -> stack.root()
  all: -> stack.all()
  parent: -> stack.parent()
  ancestors: -> stack.ancestors()
  selfAndAncestors: -> stack.selfAndAncestors()
  current: currentLayer
  resolve: resolve
  firstElement: firstElement
  allElements: allElements
  updateHistory: updateHistory
  peel: peel
