###**
Utility functions
=================
  
Unpoly comes with a number of utility functions
that might save you from loading something like [Lodash](https://lodash.com/).

@class up.util
###
up.util = do ->

  ###**
  A function that does nothing.

  @function up.util.noop
  @experimental
  ###
  noop = (->)

  ###**
  A function that returns a resolved promise.

  @function up.util.asyncNoop
  @internal
  ###
  asyncNoop = -> Promise.resolve()

  ###**
  Ensures that the given function can only be called a single time.
  Subsequent calls will return the return value of the first call.

  Note that this is a simple implementation that
  doesn't distinguish between argument lists.

  @function up.util.memoize
  @internal
  ###
  memoize = (func) ->
    cachedValue = undefined
    cached = false
    (args...) ->
      if cached
        cachedValue
      else
        cached = true
        cachedValue = func(args...)

  ###**
  Returns if the given port is the default port for the given protocol.

  @function up.util.isStandardPort
  @internal
  ###  
  isStandardPort = (protocol, port) ->
    port = port.toString()
    ((port == "" || port == "80") && protocol == 'http:') || (port == "443" && protocol == 'https:')

  ###**
  Normalizes relative paths and absolute paths to a full URL
  that can be checked for equality with other normalized URLs.
  
  By default hashes are ignored, search queries are included.
  
  @function up.util.normalizeUrl
  @param {boolean} [options.hash=false]
    Whether to include an `#hash` anchor in the normalized URL
  @param {boolean} [options.search=true]
    Whether to include a `?query` string in the normalized URL
  @param {boolean} [options.stripTrailingSlash=false]
    Whether to strip a trailing slash from the pathname
  @internal
  ###
  normalizeUrl = (urlOrAnchor, options) ->
    parts = parseUrl(urlOrAnchor)
    normalized = parts.protocol + "//" + parts.hostname
    normalized += ":#{parts.port}" unless isStandardPort(parts.protocol, parts.port)
    pathname = parts.pathname
    # Some IEs don't include a leading slash in the #pathname property.
    # We have seen this in IE11 and W3Schools claims it happens in IE9 or earlier
    # http://www.w3schools.com/jsref/prop_anchor_pathname.asp
    pathname = "/#{pathname}" unless pathname[0] == '/'
    pathname = pathname.replace(/\/$/, '') if options?.stripTrailingSlash == true
    normalized += pathname
    normalized += parts.search unless options?.search == false
    normalized += parts.hash if options?.hash == true
    normalized

  isCrossDomain = (targetUrl) ->
    currentUrl = parseUrl(location.href)
    targetUrl = parseUrl(targetUrl)
    currentUrl.protocol != targetUrl.protocol || currentUrl.host != targetUrl.host

  ###**
  Parses the given URL into components such as hostname and path.

  If the given URL is not fully qualified, it is assumed to be relative
  to the current page.

  @function up.util.parseUrl
  @return {Object}
    The parsed URL as an object with
    `protocol`, `hostname`, `port`, `pathname`, `search` and `hash`
    properties.
  @experimental
  ###
  parseUrl = (urlOrAnchor) ->
    # In case someone passed us a $link, unwrap it
    if isJQuery(urlOrAnchor)
      urlOrAnchor = up.element.get(urlOrAnchor)

    # If we are handed a parsed URL, just return it
    if urlOrAnchor.pathname
      return urlOrAnchor

    anchor = document.createElement('a')
    anchor.href = urlOrAnchor
    # In IE11 the #hostname and #port properties of such a link are empty
    # strings. However, we can fix this by assigning the anchor its own
    # href because computer:
    # https://gist.github.com/jlong/2428561#comment-1461205
    # anchor.href = anchor.href if isBlank(anchor.hostname)
    # TODO: Check if we can remove this comment without breaking IE11
    anchor

  ###**
  @function up.util.normalizeMethod
  @internal
  ###
  normalizeMethod = (method) ->
    if method
      method.toUpperCase()
    else
      'GET'

  ###**
  @function up.util.methodAllowsPayload
  @internal
  ###
  methodAllowsPayload = (method) ->
    method != 'GET' && method != 'HEAD'

  assignPolyfill = (target, sources...) ->
    for source in sources
      for own key, value of source
        target[key] = value
    target

  ###**
  Merge the own properties of one or more `sources` into the `target` object.

  @function up.util.assign
  @param {Object} target
  @param {Array<Object>} sources...
  @stable
  ###
  assign = Object.assign || assignPolyfill

  valuesPolyfill = (object) ->
    value for key, value of object

  ###**
  Returns an array of values of the given object.

  @function up.util.values
  @param {Object} object
  @return {Array<string>}
  @experimental
  ###
  objectValues = Object.values || valuesPolyfill

  listBlock = (block) ->
    if isString(block)
      (item) -> item[block]
    else
      block

  ###**
  Translate all items in an array to new array of items.

  @function up.util.map
  @param {Array<T>} array
  @param {Function(T, number): any|String} block
    A function that will be called with each element and (optional) iteration index.

    You can also pass a property name as a String,
    which will be collected from each item in the array.
  @return {Array}
    A new array containing the result of each function call.
  @stable
  ###
  map = (array, block) ->
    return [] if array.length == 0
    block = listBlock(block)
    for item, index in array
      block(item, index)

  ###**
  @function up.util.mapObject
  @internal
  ###
  mapObject = (array, pairer) ->
    merger = (object, pair) ->
      object[pair[0]] = pair[1]
      return object
    map(array, pairer).reduce(merger, {})

  ###**
  Calls the given function for each element (and, optional, index)
  of the given array.

  @function up.util.each
  @param {Array<T>} array
  @param {Function(T, number)} block
    A function that will be called with each element and (optional) iteration index.
  @stable
  ###
  each = map # note that the native Array.forEach is very slow (https://jsperf.com/fast-array-foreach)

  eachIterator = (iterator, callback) ->
    while (entry = iterator.next()) && !entry.done
      callback(entry.value)

  ###**
  Calls the given function for the given number of times.

  @function up.util.times
  @param {number} count
  @param {Function} block
  @stable
  ###
  times = (count, block) ->
    block(iteration) for iteration in [0..(count - 1)]

  ###**
  Returns whether the given argument is `null`.

  @function up.util.isNull
  @param object
  @return {boolean}
  @stable
  ###
  isNull = (object) ->
    object == null

  ###**
  Returns whether the given argument is `undefined`.

  @function up.util.isUndefined
  @param object
  @return {boolean}
  @stable
  ###
  isUndefined = (object) ->
    object == undefined

  ###**
  Returns whether the given argument is not `undefined`.

  @function up.util.isDefined
  @param object
  @return {boolean}
  @stable
  ###
  isDefined = (object) ->
    !isUndefined(object)

  ###**
  Returns whether the given argument is either `undefined` or `null`.

  Note that empty strings or zero are *not* considered to be "missing".

  For the opposite of `up.util.isMissing()` see [`up.util.isGiven()`](/up.util.isGiven).

  @function up.util.isMissing
  @param object
  @return {boolean}
  @stable
  ###
  isMissing = (object) ->
    isUndefined(object) || isNull(object)

  ###**
  Returns whether the given argument is neither `undefined` nor `null`.

  Note that empty strings or zero *are* considered to be "given".

  For the opposite of `up.util.isGiven()` see [`up.util.isMissing()`](/up.util.isMissing).

  @function up.util.isGiven
  @param object
  @return {boolean}
  @stable
  ###
  isGiven = (object) ->
    !isMissing(object)

  # isNan = (object) ->
  #   isNumber(value) && value != +value

  ###**
  Return whether the given argument is considered to be blank.

  This returns `true` for:

  - `undefined`
  - `null`
  - Empty strings
  - Empty arrays
  - An object without own enumerable properties

  All other arguments return `false`.

  @function up.util.isBlank
  @param object
  @return {boolean}
  @stable
  ###
  isBlank = (value) ->
    if isMissing(value)
      return true
    if isObject(value) && isFunction(value.isBlank)
      return value.isBlank()
    if isString(value) || isList(value)
      return value.length == 0
    if isOptions(value)
      return Object.keys(value).length == 0
    return false

  ###**
  Returns the given argument if the argument is [present](/up.util.isPresent),
  otherwise returns `undefined`.

  @function up.util.presence
  @param object
  @param {Function(T): boolean} [tester=up.util.isPresent]
    The function that will be used to test whether the argument is present.
  @return {T|undefined}
  @stable
  ###
  presence = (object, tester = isPresent) ->
    if tester(object) then object else undefined

  ###**
  Returns whether the given argument is not [blank](/up.util.isBlank).

  @function up.util.isPresent
  @param object
  @return {boolean}
  @stable
  ###
  isPresent = (object) ->
    !isBlank(object)

  ###**
  Returns whether the given argument is a function.

  @function up.util.isFunction
  @param object
  @return {boolean}
  @stable
  ###
  isFunction = (object) ->
    typeof(object) == 'function'

  ###**
  Returns whether the given argument is a string.

  @function up.util.isString
  @param object
  @return {boolean}
  @stable
  ###
  isString = (object) ->
    typeof(object) == 'string' || object instanceof String

  ###**
  Returns whether the given argument is a boolean value.

  @function up.util.isBoolean
  @param object
  @return {boolean}
  @experimental
  ###
  isBoolean = (object) ->
    typeof(object) == 'boolean' || object instanceof Boolean

  ###**
  Returns whether the given argument is a number.

  Note that this will check the argument's *type*.
  It will return `false` for a string like `"123"`.

  @function up.util.isNumber
  @param object
  @return {boolean}
  @stable
  ###
  isNumber = (object) ->
    typeof(object) == 'number' || object instanceof Number

  ###**
  Returns whether the given argument is an options hash,

  Differently from [`up.util.isObject()`], this returns false for
  functions, jQuery collections, promises, `FormData` instances and arrays.

  @function up.util.isOptions
  @param object
  @return {boolean}
  @internal
  ###
  isOptions = (object) ->
    typeof(object) == 'object' && !isNull(object) && (isUndefined(object.constructor) || object.constructor == Object)

  ###**
  Returns whether the given argument is an object.

  This also returns `true` for functions, which may behave like objects in JavaScript.

  @function up.util.isObject
  @param object
  @return {boolean}
  @stable
  ###
  isObject = (object) ->
    typeOfResult = typeof(object)
    (typeOfResult == 'object' && !isNull(object)) || typeOfResult == 'function'

  ###**
  Returns whether the given argument is a DOM element.

  @function up.util.isElement
  @param object
  @return {boolean}
  @stable
  ###
  isElement = (object) ->
    object instanceof HTMLElement

  ###**
  Returns whether the given argument is a jQuery collection.

  @function up.util.isJQuery
  @param object
  @return {boolean}
  @stable
  ###
  isJQuery = (object) ->
    up.browser.canJQuery() && (object instanceof jQuery)

  ###**
  Returns whether the given argument is an object with a `then` method.

  @function up.util.isPromise
  @param object
  @return {boolean}
  @stable
  ###
  isPromise = (object) ->
    isObject(object) && isFunction(object.then)

  ###**
  Returns whether the given argument is an array.

  @function up.util.isArray
  @param object
  @return {boolean}
  @stable
  ###
  # https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
  isArray = Array.isArray

  ###**
  Returns whether the given argument is a `FormData` instance.

  Always returns `false` in browsers that don't support `FormData`.

  @function up.util.isFormData
  @param object
  @return {boolean}
  @internal
  ###
  isFormData = (object) ->
    object instanceof FormData

  ###**
  Converts the given array-like argument into an array.

  Returns the array.

  @function up.util.toArray
  @param object
  @return {Array}
  @stable
  ###
  toArray = (object) ->
    if isArray(object)
      object
    else
      Array.prototype.slice.call(object)

  ###***
  Returns whether the given value is an `Array`, a
  [`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList) or a jQuery collection.

  Use [`up.util.isArray()`](/up.util.isArray) to test whether a value is an actual `Array`.

  @function up.util.isList
  @param value
  @return {Boolean}
  @experimental
  ###
  isList = (value) ->
    isArray(value) || isNodeList(value) || isJQuery(value)

  ###**
  Returns whether the given value is a [`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList).

  `NodeLists` are array-like objects returned by [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll).

  @function up.util.isList
  @param value
  @return {Boolean}
  @experimental
  ###
  isNodeList = (value) ->
    value instanceof NodeList

  ###**
  @function up.util.wrapList
  @return {Array|NodeList|jQuery}
  @internal
  ###
  wrapList = (value) ->
    if isList(value)
      value
    else if isMissing(value)
      []
    else
      [value]

  ###**
  Returns a shallow copy of the given array or object.

  @function up.util.copy
  @param {Object|Array} object
  @return {Object|Array}
  @stable
  ###
  copy = (object, deep)  ->
    if isArray(object)
      object = object.slice()
      copied = true
    else if isOptions(object)
      object = assign({}, object)
      copied = true
    if copied && deep
      for key, value of object
        object[key] = copy(value, true)
    object

  ###**
  Returns a deep copy of the given array or object.

  @function up.util.deepCopy
  @param {Object|Array} object
  @return {Object|Array}
  @internal
  ###
  deepCopy = (object) ->
    copy(object, true)

  ###**
  Creates a new object by merging together the properties from the given objects.

  @function up.util.merge
  @param {Array<Object>} sources...
  @return Object
  @stable
  ###
  merge = (sources...) ->
    assign({}, sources...)

#  ###**
#  Creates a new object by recursively merging together the properties from the given objects.
#
#  @function up.util.deepMerge
#  @param {Array<Object>} sources...
#  @return Object
#
#  @internal
#  ###
#  deepMerge = (sources...) ->
#    deepAssign({}, sources...)
#
#  ###**
#  @function up.util.deepAssign
#  @param {Array<Object>} sources...
#  @return Object
#  ###
#  deepAssign = (target, sources...) ->
#    for source in sources
#      for key, newValue of source
#        if isOptions(newValue)
#          oldValue = target[key]
#          if isOptions(oldValue)
#            newValue = deepMerge(oldValue, newValue)
#        target[key] = newValue
#    target

  ###**
  Creates an options hash from the given argument and some defaults.

  The semantics of this function are confusing.
  We want to get rid of this in the future.

  @function up.util.options
  @param {Object} object
  @param {Object} [defaults]
  @return {Object}
  @internal
  ###
  newOptions = (object, defaults) ->
    if defaults
      merge(defaults, object)
    else if object
      copy(object)
    else
      {}

  ###**
  Returns the first argument that is considered [given](/up.util.isGiven).

  This function is useful when you have multiple option sources and the value can be boolean.
  In that case you cannot change the sources with a `||` operator
  (since that doesn't short-circuit at `false`).
  
  @function up.util.option
  @param {Array} args...
  @internal
  ###
  option = (args...) ->
    detect(args, isGiven)

  ###**
  Passes each element in the given array to the given function.
  Returns the first element for which the function returns a truthy value.

  If no object matches, returns `undefined`.

  @function up.util.detect
  @param {Array<T>} array
  @param {Function(T): boolean} tester
  @return {T|undefined}
  @stable
  ###
  detect = (array, tester) ->
    match = undefined
    for element in array
      if tester(element)
        match = element
        break
    match

  ###**
  Returns whether the given function returns a truthy value
  for any element in the given array.

  @function up.util.any
  @param {Array<T>} array
  @param {Function(T, number): boolean} tester
    A function that will be called with each element and (optional) iteration index.

  @return {boolean}
  @experimental
  ###
  any = (array, tester) ->
    !!detectResult(array, tester)

  ###**
  Consecutively calls the given function which each element
  in the given array. Return the first truthy return value.

  Returned `undefined` iif the function does not return a truthy
  value for all elements in the array.

  @function up.util.detectResult
  @param {Array<A>} array
  @param {Function(A): B} tester
    A function that will be called with each element and (optional) iteration index.

  @return {B}
  @experimental
  ###
  detectResult = (array, tester) ->
    tester = listBlock(tester)
    for element, index in array
      if result = tester(element, index)
        return result
    return undefined

  ###**
  Returns whether the given function returns a truthy value
  for all elements in the given array.

  @function up.util.all
  @param {Array<T>} array
  @param {Function(T, number): boolean} tester
    A function that will be called with each element and (optional) iteration index.

  @return {boolean}
  @experimental
  ###
  all = (array, tester) ->
    tester = listBlock(tester)
    match = true
    for element, index in array
      unless tester(element, index)
        match = false
        break
    match

  ###**
  Returns all elements from the given array that are
  neither `null` or `undefined`.

  @function up.util.compact
  @param {Array<T>} array
  @return {Array<T>}
  @stable
  ###
  compact = (array) ->
    select array, isGiven

  ###**
  Returns the given array without duplicates.

  @function up.util.uniq
  @param {Array<T>} array
  @return {Array<T>}
  @stable
  ###
  uniq = (array) ->
    return array if array.length < 2
    setToArray(arrayToSet(array))

  ###**
  This function is like [`uniq`](/up.util.uniq), accept that
  the given function is invoked for each element to generate the value
  for which uniquness is computed.

  @function up.util.uniqBy
  @param {Array<T>} array
  @param {Function<T>: any} array
  @return {Array<T>}
  @experimental
  ###
  uniqBy = (array, mapper) ->
    return array if array.length < 2
    mapper = listBlock(mapper)
    set = new Set()
    select array, (elem, index) ->
      mapped = mapper(elem, index)
      if set.has(mapped)
        false
      else
        set.add(mapped)
        true

  ###**
  @function up.util.setToArray
  @internal
  ###
  setToArray = (set) ->
    array = []
    set.forEach (elem) -> array.push(elem)
    array

  ###**
  @function up.util.arrayToSet
  @internal
  ###
  arrayToSet = (array) ->
    set = new Set()
    array.forEach (elem) -> set.add(elem)
    set

  ###**
  Returns all elements from the given array that return
  a truthy value when passed to the given function.

  @function up.util.select
  @param {Array<T>} array
  @param {Function(T, number): boolean} tester
  @return {Array<T>}
  @stable
  ###
  select = (array, tester) ->
    tester = listBlock(tester)
    matches = []
    each array, (element, index) ->
      if tester(element, index)
        matches.push(element)
    matches

  ###**
  Returns all elements from the given array that do not return
  a truthy value when passed to the given function.

  @function up.util.reject
  @param {Array<T>} array
  @param {Function(T, number): boolean} tester
  @return {Array<T>}
  @stable
  ###
  reject = (array, tester) ->
    tester = listBlock(tester)
    select(array, (element, index) -> !tester(element, index))

  ###**
  Returns the intersection of the given two arrays.

  Implementation is not optimized. Don't use it for large arrays.

  @function up.util.intersect
  @internal
  ###
  intersect = (array1, array2) ->
    select array1, (element) ->
      contains(array2, element)

  ###**
  Waits for the given number of milliseconds, the runs the given callback.

  Instead of `up.util.setTimer(0, fn)` you can also use [`up.util.nextFrame(fn)`](/up.util.nextFrame).

  @function up.util.setTimer
  @param {number} millis
  @param {Function} callback
  @stable
  ###
  setTimer = (millis, callback) ->
    setTimeout(callback, millis)

  ###**
  Schedules the given function to be called in the
  next JavaScript execution frame.

  @function up.util.nextFrame
  @param {Function} block
  @stable
  ###
  nextFrame = (block) ->
    setTimeout(block, 0)

  ###**
  Queue a function to be executed in the next microtask.

  Returns a promise that will be resolved when the given task was executed.

  @function up.util.queueMicrotask
  @param {Function} task
  @return {Promise}
  @internal
  ###
  microtask = (task) ->
    Promise.resolve().then(task)

  ###**
  Returns the last element of the given array.

  @function up.util.last
  @param {Array<T>} array
  @return {T}
  ###
  last = (array) ->
    array[array.length - 1]

  ###**
  Returns whether the given keyboard event involved the ESC key.

  @function up.util.escapePressed
  @internal
  ###
  escapePressed = (event) ->
    key = event.key
    key == 'Escape' || key == 'Esc'

  ###**
  Returns whether the given array or string contains the given element or substring.

  @function up.util.contains
  @param {Array|string} arrayOrString
  @param elementOrSubstring
  @stable
  ###
  contains = (arrayOrString, elementOrSubstring) ->
    arrayOrString.indexOf(elementOrSubstring) >= 0

  ###**
  Returns a copy of the given object that only contains
  the given properties.

  @function up.util.only
  @param {Object} object
  @param {Array} keys...
  @stable
  ###
  only = (object, properties...) ->
    filtered = {}
    for property in properties
      if property of object
        filtered[property] = object[property]
    filtered

  ###**
  Returns a copy of the given object that contains all except
  the given properties.

  @function up.util.except
  @param {Object} object
  @param {Array} keys...
  @stable
  ###
  except = (object, properties...) ->
    filtered = copy(object)
    for property in properties
      delete filtered[property]
    filtered

#  pickBy = (obj, predicate) ->
#    result = {}
#    for k, v of obj
#      if predicate(v, k)
#        result[k] = v
#    result

  ###**
  @function up.util.isUnmodifiedKeyEvent
  @internal
  ###
  isUnmodifiedKeyEvent = (event) ->
    not (event.metaKey or event.shiftKey or event.ctrlKey)

  ###**
  @function up.util.isUnmodifiedMouseEvent
  @internal
  ###
  isUnmodifiedMouseEvent = (event) ->
    isLeftButton = isUndefined(event.button) || event.button == 0
    isLeftButton && isUnmodifiedKeyEvent(event)

  ###**
  Returns a promise that will never be resolved.

  @function up.util.unresolvablePromise
  @experimental
  ###
  unresolvablePromise = ->
    new Promise(noop)

  ###**
  Removes the given element from the given array.

  This changes the given array.

  @function up.util.remove
  @param {Array<T>} array
  @param {T} element
  @stable
  ###
  remove = (array, element) ->
    index = array.indexOf(element)
    if index >= 0
      array.splice(index, 1)
      element

  ###**
  If the given `value` is a function, calls the function with the given `args`.
  Otherwise it just returns `value`.

  @function up.util.evalOption
  @internal
  ###
  evalOption = (value, args...) ->
    if isFunction(value)
      value(args...)
    else
      value

  ###**
  @function up.util.config
  @param {Object|Function} blueprint
    Default configuration options.
    Will be restored by calling `reset` on the returned object.
  @return {Object}
    An object with a `reset` function.
  @internal
  ###
  config = (blueprint) ->
    hash = openConfig(blueprint)
    Object.preventExtensions(hash)
    hash

  ###**
  @function up.util.openConfig
  @internal
  ###
  openConfig = (blueprint = {}) ->
    hash = {}
    hash.reset = -> assign(hash, deepCopy(blueprint))
    hash.reset()
    hash

  ###**
  Throws a [JavaScript error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
  with the given message.

  The message will also be printed to the [error log](/up.log.error). Also a notification will be shown at the bottom of the screen.

  The message may contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions).

  \#\#\# Examples

      up.fail('Division by zero')
      up.fail('Unexpected result %o', result)

  @function up.fail
  @param {string} message
    A message with details about the error.

    The message can contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions)
    like `%s` or `%o`.
  @param {Array<string>} vars...
    A list of variables to replace any substitution marks in the error message.
  @experimental
  ###
  fail = (args...) ->
    if isArray(args[0])
      messageArgs = args[0]
      toastOptions = args[1] || {}
    else
      messageArgs = args
      toastOptions = {}

    up.log.error(messageArgs...)

    whenReady().then -> up.toast.open(messageArgs, toastOptions)

    asString = up.browser.sprintf(messageArgs...)
    throw new Error(asString)

  ESCAPE_HTML_ENTITY_MAP =
    "&": "&amp;"
    "<": "&lt;"
    ">": "&gt;"
    '"': '&quot;'

  ###**
  Escapes the given string of HTML by replacing control chars with their HTML entities.

  @function up.util.escapeHtml
  @param {string} string
    The text that should be escaped
  @experimental
  ###
  escapeHtml = (string) ->
    string.replace /[&<>"]/g, (char) -> ESCAPE_HTML_ENTITY_MAP[char]

  pluckKey = (object, key) ->
    value = object[key]
    delete object[key]
    value

  renameKey = (object, oldKey, newKey) ->
    object[newKey] = pluckKey(object, oldKey)

  extractCallback = (args) ->
    lastArg = last(args)
    if isFunction(lastArg)
      args.pop()

  extractOptions = (args) ->
    lastArg = last(args)
    if isOptions(lastArg)
      args.pop()
    else
      {}

  CASE_CONVERSION_GROUP = /[^\-\_]+?(?=[A-Z\-\_]|$)/g

  convertCase = (string, separator, fn) ->
    parts = string.match(CASE_CONVERSION_GROUP)
    parts = map parts, fn
    parts.join(separator)

  ###**
  Returns a copy of the given string that is transformed to `kebab-case`.

  @function up.util.kebabCase
  @param {string} string
  @return {string}
  @internal
  ###
  kebabCase = (string) ->
    convertCase string, '-', (part) -> part.toLowerCase()

  ###**
  Returns a copy of the given string that is transformed to `camelCase`.

  @function up.util.camelCase
  @param {string} string
  @return {string}
  @internal
  ###
  camelCase = (string) ->
    convertCase string, '', (part, i) ->
      if i == 0
        part.toLowerCase()
      else
        part.charAt(0).toUpperCase() + part.substr(1).toLowerCase()

  ###**
  Returns a copy of the given object with all keys renamed
  in `kebab-case`.

  Does not change the given object.

  @function up.util.kebabCaseKeys
  @param {object} obj
  @return {object}
  @internal
  ###
  kebabCaseKeys = (obj) ->
    copyWithRenamedKeys(obj, kebabCase)

  ###**
  Returns a copy of the given object with all keys renamed
  in `camelCase`.

  Does not change the given object.

  @function up.util.camelCaseKeys
  @param {object} obj
  @return {object}
  @internal
  ###
  camelCaseKeys = (obj) ->
    copyWithRenamedKeys(obj, camelCase)

#  lowerCaseKeys = (obj) ->
#    copyWithRenamedKeys(obj, (key) -> key.toLowerCase())

  copyWithRenamedKeys = (obj, keyTransformer) ->
    result = {}
    for k, v of obj
      k = keyTransformer(k)
      result[k] = v
    result

  partial = (fn, fixedArgs...) ->
    return (callArgs...) ->
      fn.apply(this, fixedArgs.concat(callArgs))

#function throttle(callback, limit) { // From https://jsfiddle.net/jonathansampson/m7G64/
#  var wait = false                   // Initially, we're not waiting
#  return function () {               // We return a throttled function
#    if (!wait) {                     // If we're not waiting
#      callback.call()                // Execute users function
#      wait = true                    // Prevent future invocations
#      setTimeout(function () {       // After a period of time
#        wait = false                 // And allow future invocations
#      }, limit)
#    }
#  }
#}

  whenReady = memoize ->
    readyState = document.readyState
    # Values are "loading", "interactive" and "completed".
    # https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
    if readyState != 'loading'
      Promise.resolve()
    else
      new Promise (resolve) ->
        document.addEventListener('DOMContentLoaded', resolve)

  identity = (arg) -> arg

#  ###**
#  ###
#  parsePath = (input) ->
#    path = []
#    pattern = /([^\.\[\]\"\']+)|\[\'([^\']+?)\'\]|\[\"([^\"]+?)\"\]|\[([^\]]+?)\]/g
#    while match = pattern.exec(input)
#      path.push(match[1] || match[2] || match[3] || match[4])
#    path

  ###**
  Given a function that will return a promise, returns a proxy function
  with an additional `.promise` attribute.

  When the proxy is called, the inner function is called.
  The proxy's `.promise` attribute is available even before the function is called
  and will resolve when the inner function's returned promise resolves.

  If the inner function does not return a promise, the proxy's `.promise` attribute
  will resolve as soon as the inner function returns.

  @function up.util.previewable
  @internal
  ###
  previewable = (fun) ->
    deferred = newDeferred()
    preview = (args...) ->
      funValue = fun(args...)
      # If funValue is again a Promise, it will defer resolution of `deferred`
      # until `funValue` is resolved.
      deferred.resolve(funValue)
      funValue
    preview.promise = deferred.promise()
    preview

  ###**
  @function up.util.sequence
  @param {Array<Function>} functions...
  @return {Function}
    A function that will call all `functions` if called.

  @internal
  ###
  sequence = (functions...) ->
    ->
      map functions, (f) -> f()

#  ###**
#  @function up.util.race
#  @internal
#  ###
#  race = (promises...) ->
#    raceDone = newDeferred()
#    each promises, (promise) ->
#      promise.then -> raceDone.resolve()
#    raceDone.promise()

  ###**
  Returns `'left'` if the center of the given element is in the left 50% of the screen.
  Otherwise returns `'right'`.

  @function up.util.horizontalScreenHalf
  @internal
  ###
  horizontalScreenHalf = (element) ->
    elementDims = element.getBoundingClientRect()
    elementMid = elementDims.left + 0.5 * elementDims.width
    screenMid = 0.5 * up.browser.documentViewportWidth()
    if elementMid < screenMid
      'left'
    else
      'right'

  ###**
  Flattens the given `array` a single level deep.

  @function up.util.flatten
  @param {Array} array
    An array which might contain other arrays
  @return {Array}
    The flattened array
  @internal
  ###
  flatten = (array) ->
    flattened = []
    for object in array
      if isList(object)
        flattened.push(object...)
      else
        flattened.push(object)
    flattened

  flatMap = (array, block) ->
    flatten map(array, block)

  ###**
  Returns whether the given value is truthy.

  @function up.util.isTruthy
  @internal
  ###
  isTruthy = (object) ->
    !!object

  ###**
  Sets the given callback as both fulfillment and rejection handler for the given promise.

  @function up.util.always
  @internal
  ###
  always = (promise, callback) ->
    promise.then(callback, callback)

  ###**
  # Registers an empty rejection handler with the given promise.
  # This prevents browsers from printing "Uncaught (in promise)" to the error
  # console when the promise is rejection.
  #
  # This is helpful for event handlers where it is clear that no rejection
  # handler will be registered:
  #
  #     up.on('submit', 'form[up-target]', (event, $form) => {
  #       promise = up.submit($form)
  #       up.util.muteRejection(promise)
  #     })
  #
  # Does nothing if passed a missing value.
  #
  # @function up.util.muteRejection
  # @param {Promise|undefined|null} promise
  # @return {Promise}
  ###
  muteRejection = (promise) ->
    promise?.catch(noop)

  ###**
  @function up.util.newDeferred
  @internal
  ###
  ###**
  @function up.util.newDeferred
  @internal
  ###
  newDeferred = ->
    resolveFn = undefined
    rejectFn = undefined
    nativePromise = new Promise (givenResolve, givenReject) ->
      resolveFn = givenResolve
      rejectFn = givenReject
    nativePromise.resolve = resolveFn
    nativePromise.reject = rejectFn
    nativePromise.promise = -> nativePromise # just return self
    nativePromise

  ###**
  Calls the given block. If the block throws an exception,
  a rejected promise is returned instead.

  @function up.util.rejectOnError
  @internal
  ###
  rejectOnError = (block) ->
    try
      block()
    catch error
      Promise.reject(error)

  sum = (list, block) ->
    block = listBlock(block)
    totalValue = 0
    for entry in list
      entryValue = block(entry)
      if isGiven(entryValue) # ignore undefined/null, like SQL would do
        totalValue += entryValue
    totalValue

  isBasicObjectProperty = (k) ->
    Object.prototype.hasOwnProperty(k)

  isEqual = (a, b) ->
    if typeof(a) != typeof(b)
      false
    else if isArray(a)
      a.length == b.length && all(a, (elem, index) -> isEqual(elem, b[index]))
    else if isObject(a)
      if isFunction(a.isEqual)
        a.isEqual(b)
      else
        aKeys = Object.keys(a)
        bKeys = Object.keys(b)
        if isEqual(aKeys, bKeys)
          all aKeys, (aKey) -> isEqual(a[aKey], b[aKey])
        else
          false
    else
      a == b

  splitValues = (value, separator = ' ') ->
    values = value.split(separator)
    values = map values, (v) -> v.trim()
    values = select(values, isPresent)
    values

  endsWith = (string, search) ->
    if search.length > string.length
      false
    else
      string.substring(string.length - search.length) == search

  simpleEase = (x) ->
    # easing: http://fooplot.com/?lang=de#W3sidHlwZSI6MCwiZXEiOiJ4PDAuNT8yKngqeDp4Kig0LXgqMiktMSIsImNvbG9yIjoiIzEzRjIxNyJ9LHsidHlwZSI6MCwiZXEiOiJzaW4oKHheMC43LTAuNSkqcGkpKjAuNSswLjUiLCJjb2xvciI6IiMxQTUyRUQifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMS40NyIsIjEuNzgiLCItMC41NSIsIjEuNDUiXX1d
    # easing nice: sin((x^0.7-0.5)*pi)*0.5+0.5
    # easing performant: x < 0.5 ? 2*x*x : x*(4 - x*2)-1
    # https://jsperf.com/easings/1
    # Math.sin((Math.pow(x, 0.7) - 0.5) * Math.PI) * 0.5 + 0.5
    if x < 0.5
      2*x*x
    else
      x*(4 - x*2)-1

  wrapValue = (object, constructor) ->
    if object instanceof constructor
      # This object has gone through instantiation and normalization before.
      object
    else
      new constructor(object)

#  wrapArray = (objOrArray) ->
#    if isUndefined(objOrArray)
#      []
#    else if isArray(objOrArray)
#      objOrArray
#    else
#      [objOrArray]

  <% if ENV['JS_KNIFE'] %>knife: eval(Knife.point)<% end %>
  parseUrl: parseUrl
  normalizeUrl: normalizeUrl
  normalizeMethod: normalizeMethod
  methodAllowsPayload: methodAllowsPayload
#  isGoodSelector: isGoodSelector
  assign: assign
  assignPolyfill: assignPolyfill
  copy: copy
  deepCopy: deepCopy
  merge: merge
#  deepAssign: deepAssign
#  deepMerge: deepMerge
  options: newOptions
  option: option
  fail: fail
  each: each
  eachIterator: eachIterator
  map: map
  flatMap: flatMap
  mapObject: mapObject
  times: times
  detectResult: detectResult
  any: any
  all: all
  detect: detect
  select: select
  reject: reject
  intersect: intersect
  compact: compact
  uniq: uniq
  uniqBy: uniqBy
  last: last
  isNull: isNull
  isDefined: isDefined
  isUndefined: isUndefined
  isGiven: isGiven
  isMissing: isMissing
  isPresent: isPresent
  isBlank: isBlank
  presence: presence
  isObject: isObject
  isFunction: isFunction
  isString: isString
  isBoolean: isBoolean
  isNumber: isNumber
  isElement: isElement
  isJQuery: isJQuery
  isPromise: isPromise
  isOptions: isOptions
  isArray: isArray
  isFormData: isFormData
  isUnmodifiedKeyEvent: isUnmodifiedKeyEvent
  isUnmodifiedMouseEvent: isUnmodifiedMouseEvent
  setTimer: setTimer
  nextFrame: nextFrame
  escapePressed: escapePressed
  contains: contains
  toArray: toArray
#  pushAll: pushAll
  only: only
  except: except
#  pickBy: pickBy
  unresolvablePromise: unresolvablePromise
  remove: remove
  memoize: memoize
  config: config
  openConfig: openConfig
  camelCase: camelCase
  camelCaseKeys: camelCaseKeys
  # lowerCaseKeys: lowerCaseKeys
  kebabCase: kebabCase
  kebabCaseKeys: kebabCaseKeys
  error: fail
  pluckKey: pluckKey
  renameKey: renameKey
  extractOptions: extractOptions
  extractCallback: extractCallback
  noop: noop
  asyncNoop: asyncNoop
  whenReady: whenReady
  identity: identity
  escapeHtml: escapeHtml
  sequence: sequence
  previewable: previewable
  # parsePath: parsePath
  evalOption: evalOption
  horizontalScreenHalf: horizontalScreenHalf
  flatten: flatten
  isTruthy: isTruthy
  newDeferred: newDeferred
  always: always
  muteRejection: muteRejection
  rejectOnError: rejectOnError
  isBasicObjectProperty: isBasicObjectProperty
  isCrossDomain: isCrossDomain
  microtask: microtask
  isEqual: isEqual
  splitValues : splitValues
  endsWith: endsWith
  sum: sum
#  wrapArray: wrapArray
  wrapList: wrapList
  wrapValue: wrapValue
  simpleEase: simpleEase
  values: objectValues
  partial: partial
  arrayToSet: arrayToSet
  setToArray: setToArray

up.fail = up.util.fail
