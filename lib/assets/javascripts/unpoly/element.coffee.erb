#= require ./classes/selector

up.element = do ->

  u = up.util

  NONE = { getAttribute: -> undefined }

  s = (selector) ->
    up.Selector.parse(selector)

  ###**
  @function up.element.descendant
  @internal
  ###
  descendant = (root, selector) ->
    s(selector).descendant(root)

  ###**
  @function up.element.descendants
  @internal
  ###
  descendants = (root, selector) ->
    s(selector).descendants(root)

  ###**
  @function up.element.first
  @internal
  ###
  first = (selector) ->
    descendant(document, selector)

  ###**
  @function up.element.all
  @internal
  ###
  all = (selector) ->
    descendants(document, selector)

  ###**
  @function up.element.subtree
  @internal
  ###
  subtree = (root, selector) ->
    s(selector).subtree(root)

  ###**
  @function up.element.closest
  @internal
  ###
  closest = (element, selector) ->
    s(selector).closest(element)

  ###**
  @function up.element.matches
  @internal
  ###
  matches = (element, selector) ->
    s(selector).matches(element)

  ###**
  @function up.element.ancestor
  @internal
  ###
  ancestor = (element, selector) ->
    s(selector).ancestor(element)

  ###**
  If given a jQuery collection, returns the first native DOM element in the collection.
  If given a string, returns the first element matching that string.
  If given any other argument, returns the argument unchanged.

  @function up.element.get
  @param {jQuery|Element|String} object
  @return {Element}
  @internal
  ###
  getOne = (object) ->
    if u.isJQuery(object)
      if object.length > 1
        up.fail('up.element.get(): Cannot cast a multi-element jQuery collection to a single elenent')
      object[0]
    else if u.isString(object)
      first(object)
    else
      object

  ###**
  If given a string, returns the all elements matching that string.
  If given any other argument, returns the argument [wrapped as an array](/up.util.wrapList).

  @function up.element.list
  @param {jQuery|Element|String} object
  @return {Element}
  @internal
  ###
  getList = (args...) ->
    u.flatMap args, valueToList

  valueToList = (value) ->
    if u.isString(value)
      all(value)
    else
      u.wrapList(value)

  ###**
  @function up.element.emit
  @internal
  ###
  emit = (element, name, props = {}) ->
    event = document.createEvent('Event')
    event.initEvent(name, true, true) # name, bubbles, cancelable
    u.assign(event, props)

    # IE11 does not set { defaultPrevented: true } after #preventDefault()
    # was called on a custom event.
    # See discussion here: https://stackoverflow.com/questions/23349191
    if up.browser.isIE11()
      event.preventDefault = ->
        Object.defineProperty(event, 'defaultPrevented', get: -> true)

    element.dispatchEvent(event)

    return event

#  assertIsElement = (element) ->
#    unless u.isElement(element)
#      up.fail('Not an element: %o', element)

  ###**
  @function up.element.remove
  @internal
  ###
  remove = (element) ->
    if element.remove
      element.remove()
    # IE does not support Element#remove()
    else if parent = element.parentNode
      parent.removeChild(element)

  ###**
  @function up.element.hide
  @internal
  ###
  hide = (element) ->
    element.style.display = 'none'

  ###**
  @function up.element.show
  @internal
  ###
  show = (element) ->
    element.style.display = ''

  ###**
  @function up.element.toggle
  @internal
  ###
  toggle = (element, newVisible) ->
    if newVisible
      show(element)
    else
      hide(element)

#  trace = (fn) ->
#    (args...) ->
#      console.debug("Calling %o with %o", fn, args)
#      fn(args...)

  ###**
  @function up.element.toggleClass
  @internal
  ###
  toggleClass = (element, klass, newPresent) ->
    fn = if newPresent then 'add' else 'remove'
    element.classList[fn](klass)

  ###**
  @function up.element.setAttrs
  @internal
  ###
  setAttrs = (element, attrMap) ->
    for key, value of attrMap
      element.setAttribute(key, value)

  ###**
  @function up.element.metaContent
  @internal
  ###
  metaContent = (name) ->
    selector = "meta" + attributeSelector('name', name)
    first(selector)?.getAttribute('content')

  ###**
  @function up.element.insertBefore
  @internal
  ###
  insertBefore = (existingElement, newElement) ->
    existingElement.insertAdjacentElement('beforebegin', newElement)

#  insertAfter = (existingElement, newElement) ->
#    existingElement.insertAdjacentElement('afterend', newElement)

  ###**
  @function up.element.replace
  @internal
  ###
  replace = (oldElement, newElement) ->
    oldElement.parentElement.replaceChild(newElement, oldElement)

  ###**
  @function up.element.setAttrs
  @internal
  ###
  setAttrs = (element, attrs) ->
    for name, value of attrs
      element.setAttribute(name, value)

  ###**
  @function up.element.createFromSelector
  @internal
  ###
  createFromSelector = (givenSelector) ->
    # Extract attribute values before we do anything else.
    # Attribute values might contain spaces, and then we would incorrectly
    # split depths at that space.
    attrValues = []
    selectorWithoutAttrValues = givenSelector.replace /\[([\w-]+)(?:=(["'])?([^"'\]]*?)\2)?\]/g, (_match, attrName, _quote, attrValue) ->
      attrValues.push(attrValue || '')
      "[#{attrName}]"

    depths = selectorWithoutAttrValues.split(/[ >]+/)
    rootElement = undefined
    depthElement = undefined
    previousElement = undefined

    for depthSelector in depths
      tagName = undefined

      depthSelector = depthSelector.replace /^[\w-]+/, (match) ->
        tagName = match
        ''

      depthElement = document.createElement(tagName || 'div')
      rootElement ||= depthElement

      depthSelector = depthSelector.replace /\#([\w-]+)/, (_match, id) ->
        depthElement.id = id
        ''

      depthSelector = depthSelector.replace /\.([\w-]+)/g, (_match, className) ->
        depthElement.classList.add(className)
        ''

      # If we have stripped out attrValues at the beginning of the function,
      # they have been replaced with the attribute name only (as "[name]").
      if attrValues.length
        depthSelector = depthSelector.replace /\[([\w-]+)\]/g, (_match, attrName) ->
          depthElement.setAttribute(attrName, attrValues.shift())
          ''

      unless depthSelector == ''
        throw new Error('Cannot parse selector: ' + givenSelector)

      previousElement?.appendChild(depthElement)
      previousElement = depthElement

    rootElement

  # createDivWithClass = (className) ->
  #   element = document.createElement('div')
  #   element.className = className
  #   element

  subscribeEvents = (fn, elements, eventNames, callback) ->
    for element in u.wrapList(elements)
      for eventName in u.wrapList(eventNames)
        element[fn](eventName, callback)

  bind = u.partial(subscribeEvents, 'addEventListener')

  unbind = u.partial(subscribeEvents, 'removeEventListener')

  ###**
  @function up.element.affix
  @internal
  ###
  affix = (container, selector, attrs) ->
    element = createFromSelector(selector)
    if attrs
      if classValue = u.pluckKey(attrs, 'class')
        for klass in u.wrapList(classValue)
          element.classList.add(klass)
      if styleValue = u.pluckKey(attrs, 'style')
        setInlineStyle(element, styleValue)
      if textValue = u.pluckKey(attrs, 'text')
        element.innerText = textValue
      setAttrs(element, attrs)
    container.appendChild(element)
    element

  ###**
  Returns a CSS selector that matches the given element as good as possible.

  This uses, in decreasing order of priority:

  - The element's `up-id` attribute
  - The element's ID
  - The element's name
  - The element's classes
  - The element's tag names

  @function up.element.toSelector
  @param {string|Element|jQuery}
    The element for which to create a selector.
  @experimental
  ###
  toSelector = (element) ->
    return element if u.isString(element)

    # resolveSelector() might be called with jQuery collections
    element = getOne(element)

    selector = undefined

    if isSingleton(element)
      selector = elementTagName(element)
    else if upId = element.getAttribute("up-id")
      selector = attributeSelector('up-id', upId)
    else if id = element.getAttribute("id")
      if id.match(/^[a-z0-9\-_]+$/i)
        selector = "##{id}"
      else
        selector = attributeSelector('id', id)
    else if name = element.getAttribute("name")
      selector = elementTagName(element) + attributeSelector('name', name)
    else if classes = u.presence(nonUpClasses(element))
      selector = ''
      for klass in classes
        selector += ".#{klass}"
    else if ariaLabel = element.getAttribute("aria-label")
      selector = attributeSelector('aria-label', ariaLabel)
    else
      selector = elementTagName(element)

    return selector

  ###**
  @function up.element.isSingleton
  @internal
  ###
  isSingleton = (element) ->
    matches(element, 'html, body, head, title')

  elementTagName = (element) ->
    element.tagName.toLowerCase()

  ###**
  @function up.element.attributeSelector
  @internal
  ###
  attributeSelector = (attribute, value) ->
    value = value.replace(/"/g, '\\"')
    "[#{attribute}=\"#{value}\"]"

  nonUpClasses = (element) ->
    classString = element.className
    classes = u.splitValues(classString)
    u.reject classes, (klass) -> klass.match(/^up-/)

  ###**
  @function up.element.createDocumentFromHtml
  @internal
  ###
  createDocumentFromHtml = (html) ->
    # IE9 cannot set innerHTML on a <html> or <head> element.
    parser = new DOMParser()
    return parser.parseFromString(html, 'text/html')

  ###**
  @function up.element.createFromHtml
  @internal
  ###
  createFromHtml = (html) ->
    doc = createDocumentFromHtml(html)
    return doc.body.children[0]

  ###**
  @function up.element.root
  @internal
  ###
  getRoot = ->
    document.documentElement

  ###**
  Forces the browser to paint the given element now.

  @function up.element.paint
  @internal
  ###
  paint = (element) ->
    element.offsetHeight

  ###**
  @function up.element.concludeCssTransition
  @internal
  ###
  concludeCssTransition = (element) ->
    undo = setTemporaryStyle(element, transition: 'none')
    # Browsers need to paint at least one frame without a transition to stop the
    # animation. In theory we could just wait until the next paint, but in case
    # someone will set another transition after us, let's force a repaint here.
    paint(element)
    return undo

  ###**
  Returns whether the given element has a CSS transition set.

  @function up.util.hasCssTransition
  @return {boolean}
  @internal
  ###
  hasCssTransition = (elementOrStyleHash) ->
    if u.isOptions(elementOrStyleHash)
      styleHash = elementOrStyleHash
    else
      styleHash = computedStyle(elementOrStyleHash)

    prop = styleHash.transitionProperty
    duration = styleHash.transitionDuration
    # The default transition for elements is actually "all 0s ease 0s"
    # instead of "none", although that has the same effect as "none".
    noTransition = (prop == 'none' || (prop == 'all' && duration == 0))
    not noTransition

  ###**
  @function up.util.fixedToAbsolute
  @internal
  ###
  fixedToAbsolute = (element) ->
    elementRectAsFixed = element.getBoundingClientRect()

    # Set the position to 'absolute' so it gains an offsetParent
    element.style.position = 'absolute'

    offsetParentRect = element.offsetParent.getBoundingClientRect()

    setInlineStyle element,
      left: elementRectAsFixed.left - computedStyleNumber(element, 'margin-left') - offsetParentRect.left
      top: elementRectAsFixed.top - computedStyleNumber(element, 'margin-top') - offsetParentRect.top
      right: ''
      bottom: ''

  ###**
  On the given element, set attributes that are still missing.

  @function up.element.setMissingAttrs
  @internal
  ###
  setMissingAttrs = (element, attrs) ->
    for key, value of attrs
      if u.isMissing(element.getAttribute(key))
        element.setAttribute(key, value)

  ###**
  @function up.element.unwrap
  @internal
  ###
  unwrap = (wrapper) ->
    parent = wrapper.parentNode;
    wrappedNodes = u.toArray(wrapper.childNodes)
    u.each wrappedNodes, (wrappedNode) ->
      parent.insertBefore(wrappedNode, wrapper)
    parent.removeChild(wrapper)

  ###**
  Returns the value for the given element and attribute, if it is present.

  If it is blank it returns `undefined`.

  @function up.util.presentAttr
  @internal
  ###
  presentAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    u.presence(value)

  ###**
  @function up.util.castedAttr
  @internal
  ###
  castedAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    switch value
      when 'false' then false
      when 'true', '', attribute then true
      else value # other strings, undefined, null, ...

  ###**
  @function up.util.numberAttr
  @internal
  ###
  numberAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    if value?.match(/^[\d\.]+$/)
      parseFloat(value)

  ###**
  Reads the given attribute from the element, parsed JSON.

  Returns `undefined` if the attribute value is [blank](/up.util.isBlank).

  @function up.element.jsonAttr
  @internal
  ###
  jsonAttr = (element, attribute) ->
    # The document does not respond to #getAttribute()
    if json = element.getAttribute?(attribute)?.trim()
      JSON.parse(json)

  ###**
  Temporarily sets the CSS for the given element.

  @function up.util.setTemporaryStyle
  @param {jQuery} $element
  @param {Object} css
  @param {Function} [block]
    If given, the CSS is set, the block is called and
    the old CSS is restored.
  @return {Function}
    A function that restores the original CSS when called.
  @internal
  ###
  setTemporaryStyle = (element, newCss, block) ->
    oldStyles = inlineStyle(element, Object.keys(newCss))
    restoreOldStyles = -> setInlineStyle(element, oldStyles)
    setInlineStyle(element, newCss)
    if block
      # If a block was passed, we run the block and restore old styles.
      block()
      restoreOldStyles()
    else
      # If no block was passed, we return the restoration function.
      restoreOldStyles

  ###**
  Gets the computed style(s) for the given element.

  @function up.element.computedStyle
  @param {jQuery|Element} element
  @param {String|Array} propOrProps
    One or more CSS property names in camelCase.
  @return {string|object}
  @internal
  ###
  computedStyle = (element, props) ->
    element = up.element.get(element)
    style = window.getComputedStyle(element)
    extractFromStyleObject(style, props)

  ###**
  Gets a computed style value for the given element.
  If a value is set, the value is parsed to a number before returning.

  @function up.element.computedStyleNumber
  @param {jQuery|Element} element
  @param {String} prop
    A CSS property name in camelCase.
  @return {string|object}
  @internal
  ###
  computedStyleNumber = (element, prop) ->
    rawValue = computedStyle(element, prop)
    if u.isGiven(rawValue)
      parseFloat(rawValue)
    else
      undefined

  ###**
  Gets the given inline style(s) from the given element's `[style]` attribute.

  @function up.element.inlineStyle
  @param {jQuery|Element} element
  @param {String|Array} propOrProps
    One or more CSS property names in camelCase.
  @return {string|object}
  @internal
  ###
  inlineStyle = (element, props) ->
    element = up.element.get(element)
    style = element.style
    extractFromStyleObject(style, props)

  extractFromStyleObject = (style, keyOrKeys) ->
    if u.isString(keyOrKeys)
      style[keyOrKeys]
    else # array
      u.only(style, keyOrKeys...)

  ###**
  Merges the given inline style(s) into the given element's `[style]` attribute.

  @function up.element.setInlineStyle
  @param {jQuery|Element} element
  @param {Object} props
    One or more CSS properties with camelCase keys.
  @return {string|object}
  @internal
  ###
  setInlineStyle = (element, props) ->
    element = up.element.get(element)
    style = element.style
    for key, value of props
      value = normalizeStyleValueForWrite(key, value)
      style[key] = value

  normalizeStyleValueForWrite = (key, value) ->
    if u.isMissing(value)
      value = ''
    else if CSS_LENGTH_PROPS.has(key)
      value = cssLength(value)
    value

  CSS_LENGTH_PROPS = u.arrayToSet [
    'top', 'right', 'bottom', 'left',
    'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
    'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',
    'width', 'height',
    'maxWidth', 'maxHeight',
    'minWidth', 'minHeight',
  ]

  ###**
  Converts the given value to a CSS length value, adding a `px` unit if required.

  @function up.util.cssLength
  @internal
  ###
  cssLength = (obj) ->
    if u.isNumber(obj) || (u.isString(obj) && /^\d+$/.test(obj))
      obj.toString() + "px"
    else
      obj

  ###**
  Resolves the given CSS selector (which might contain `&` references)
  to a full CSS selector without ampersands.

  If passed an `Element` or `jQuery` element, returns a CSS selector string
  for that element.

  @function up.element.resolveSelector
  @param {string|Element|jQuery} selectorOrElement
  @param {string|Element|jQuery} origin
    The element that this selector resolution is relative to.
    That element's selector will be substituted for `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @return {string}
  @internal
  ###
  resolveSelector = (selectorOrElement, origin) ->
    if u.isString(selectorOrElement)
      selector = selectorOrElement
      if u.contains(selector, '&')
        if u.isPresent(origin) # isPresent returns false for empty jQuery collection
          originSelector = toSelector(origin)
          selector = selector.replace(/\&/, originSelector)
        else
          up.fail("Found origin reference (%s) in selector %s, but no origin was given", '&', selector)
    else
      selector = toSelector(selectorOrElement)
    selector

  <% if ENV['JS_KNIFE'] %>knife: eval(Knife.point)<% end %>
  # also document :has()!
  descendant: descendant # same as element.querySelector. it's a shitty name though. can we turn this into up.element.first(root, 'selector') ?
  descendants: descendants # same as element.querySelectorAll it's a shitty name though. can we turn this into up.element.all(root, 'selector') ?
  first: first # same as document.querySelector
  all: all # same as document.querySelectorAll
  subtree: subtree # practical
  closest: closest # needed for IE11
  matches: matches # needed for IE11
  ancestor: ancestor # not practical. we use it to implement closest:
  get: getOne # practical for code that also works with jQuery
  list: getList # practical for composing multiple collections, or wrapping.
  emit: emit # we already offer up.emit, so let's keep this internal.
  remove: remove # needed for IE11
  toggle: toggle # practical, but we need to (1) implement visibility-detection
  toggleClass: toggleClass # practical, but we need to implement class detection
  hide: hide # practical
  show: show # practical, but need to restore the same `display` as before hide
  setAttrs: setAttrs # practical
  metaContent: metaContent # internal
  replace: replace # needed for IE11
  insertBefore: insertBefore # internal shortcut, people can use insertAdjacentElement and i don't want to support insertAfter when I don't need it.
  createFromSelector: createFromSelector # practical for element creation. must support { style } / { attrs } options.
  setAttrs: setAttrs # practical
  affix: affix # practical for element creation
  on: bind # confusing because we have up.on. let's rather move this to bus and support: up.on(element, event, callback).
  off: unbind # confusing because we have up.on. let's rather move this to bus and support: up.off(element, event, callback).
  toSelector: toSelector # practical
  isSingleton: isSingleton # internal
  attributeSelector: attributeSelector # internal
  createDocumentFromHtml: createDocumentFromHtml # internal
  createFromHtml: createFromHtml # practical for element creation
  root: getRoot # internal
  paint: paint # internal
  concludeCssTransition: concludeCssTransition # internal
  hasCssTransition: hasCssTransition # internal
  fixedToAbsolute: fixedToAbsolute # internal
  setMissingAttrs: setMissingAttrs # internal
  unwrap: unwrap # practical for jQuery migration
  presentAttr: presentAttr # experimental
  castedAttr: castedAttr # it's practical, but i cannot find a good name. people might expect it to cast to number, too. but i don't need that for my own code.
  numberAttr: numberAttr # practical
  jsonAttr: jsonAttr # practical
  setTemporaryStyle: setTemporaryStyle # practical
  computedStyle: computedStyle # practical. should be named style outside this module.
  computedStyleNumber: computedStyleNumber # practical. should be named styleNumber outside this module.
  inlineStyle: inlineStyle # internal
  setInlineStyle: setInlineStyle # practical. should be named setStyle.
  resolveSelector: resolveSelector # internal
  none: -> NONE # internal
