#= require ./classes/selector

###**
DOM helpers
===========

Text here

@class up.element
###
up.element = do ->

  u = up.util

  ###**
  Returns a null-object that mimics an `Element`.

  @function up.util.none
  @internal
  ###
  NONE = { getAttribute: -> undefined }

  ###**
  Matches all elements that have a descendant matching the given selector.

  \#\#\# Example

  `up.element.all('div:has(span)')`  matches all `<div>` elements with at least one `<span>` among its descendants:

  ```html
  <div>
    <span>Will be matched</span>
  </div>
  <div>
    Will NOT be matched
  </div>
  <div>
    <span>Will be matched</span>
  </div>
  ```

  \#\#\# Compatibility

  `:has()` is supported by all Unpoly functions (like [`up.element.all()`](/up.element.all)) and
   selectors (like [`[up-target]`](/up-target)).

  As a [level 4 CSS selector](https://drafts.csswg.org/selectors-4/#relational),
  `:has()` [has yet to be implemented](https://caniuse.com/#feat=css-has)
  in native browser functions like [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll).

  You can also use [`:has()` in jQuery](https://api.jquery.com/has-selector/).

  @selector :has()
  @experimental
  ###

  parseSelector = (selector) ->
    up.Selector.parse(selector)

  ###**
  Returns the first descendant element matching the given selector.

  It is similar to [`element.querySelector`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector),
  but also supports the [`:has()`](/has) selector.

  @function up.element.first
  @param {Element} [parent=document]
    The parent element whose descendants to search.

    If omitted, all elements in the `document` will be searched.
  @param {string} selector
    The CSS selector to match.
  @return {Element|undefined|null}
    The first element matching the selector.

    Returns `null` or `undefined` if no element macthes.
  @experimental
  ###
  first = (args...) ->
    selector = args.pop()
    parent = args[0] ? document
    parseSelector(selector).descendant(parent)

  ###**
  Returns all descendant elements matching the given selector.

  @function up.element.all
  @param {Element} [parent=document]
    The parent element whose descendants to search.

    If omitted, all elements in the `document` will be searched.
  @param {string} selector
    The CSS selector to match.
  @return {NodeList<Element>|Array<Element>}
    A list of all elements matching the selector.

    Returns an empty list if there are no matches.
  @experimental
  ###
  all = (args...) ->
    selector = args.pop()
    parent = args[0] ? document
    parseSelector(selector).descendants(parent)

  ###**
  Returns a list of the given parent's descendants matching the given selector.
  The list will also include the parent element if it matches the selector itself.

  @function up.element.subtree
  @param {Element} parent
    The parent element for the search.
  @param {string} selector
    The CSS selector to match.
  @return {NodeList<Element>|Array<Element>}
    A list of all matching elements.
  @experimental
  ###
  subtree = (root, selector) ->
    parseSelector(selector).subtree(root)

  ###**
  Returns the first element that matches the selector by testing the element itself
  and traversing up through its ancestors in the DOM tree.

  @function up.element.closest
  @param {Element} element
    The element on which to start the search.
  @param {string}
    The CSS selector to match.
  @return {Element|null|undefined} element
    The matching element.

    Returns `null` or `undefined` if no element matches.
  @experimental
  ###
  closest = (element, selector) ->
    parseSelector(selector).closest(element)

  ###**
  Returns whether the given element matches the given CSS selector.

  @function up.element.matches
  @param {Element} element
    The element to check.
  @param {string} selector
    The CSS selector to match.
  @return {boolean}
    Whether `element` matches `selector`.
  @experimental
  ###
  matches = (element, selector) ->
    parseSelector(selector).matches(element)

  ###**
  @function up.element.ancestor
  @internal
  ###
  ancestor = (element, selector) ->
    parseSelector(selector).ancestor(element)

  ###**
  Casts the given value to a native [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element).

  This is useful when working with jQuery values, or to allow callers to pass CSS selectors
  instead of elements.

  \#\#\# Casting rules

  - If given an element, returns that element.
  - If given a CSS selector string, returns the [first element matching](/up.element.first) that selector.
  - If given a jQuery collection , returns the first element in the collection.
    Throws an error if the collection contains more than one element.
  - If given any other argument (`undefined`, `null`, `document`, `window`â€¦), returns the argument unchanged.

  @function up.element.get
  @param {jQuery|Element|String} value
    The value to cast.
  @return {Element}
    The obtained `Element`.
  @experimental
  ###
  getOne = (value) ->
    if u.isElement(value) # Return an element before we run any other expensive checks
      value
    else if u.isString(value)
      first(value)
    else if u.isJQuery(value)
      if value.length > 1
        up.fail('up.element.get(): Cannot cast multiple elements (%o) to a single element', value)
      value[0]
    else
      # undefined, null, Window, Document, DocumentFragment, ...
      value

  ###**
  Composes a list of elements from the given arguments.

  \#\#\# Casting rules

  - If given a string, returns the all elements matching that string.
  - If given any other argument, returns the argument [wrapped as a list](/up.util.wrapList).

  \#\#\# Example

  ```javascript
  $jquery = $('.jquery')                          // returns jQuery (2) [div.jquery, div.jquery]
  nodeList = document.querySelectorAll('.node')   // returns NodeList (2) [div.node, div.node]
  element = document.querySelector('.element')    // returns Element div.element
  selector = '.selector'                          // returns String '.selector'

  elements = up.element.list($jquery, nodeList, undefined, element, selector)
  // returns [div.jquery, div.jquery, div.node, div.node, div.element, div.selector]
  ```

  @function up.element.list
  @param {Array<jQuery|Element|Array<Element>|String|undefined|null>} ...args
  @return {Array<Element>}
  @internal
  ###
  getList = (args...) ->
    u.flatMap args, valueToList

  valueToList = (value) ->
    if u.isString(value)
      all(value)
    else
      u.wrapList(value)

#  assertIsElement = (element) ->
#    unless u.isElement(element)
#      up.fail('Not an element: %o', element)

  ###**
  Removes the given element from the object tree.

  If you don't need IE11 support you may also use the built-in
  [`Element#remove()`](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove) to the same effect.

  @function up.element.remove
  @param {Element} element
    The element to remove.
  @experimental
  ###
  remove = (element) ->
    if element.remove
      element.remove()
    # IE does not support Element#remove()
    else if parent = element.parentNode
      parent.removeChild(element)

  ###**
  Hides the given element.

  The element is hidden by setting an [inline style](https://www.codecademy.com/articles/html-inline-styles)
  of `{ display: none }`.

  @function up.element.hide
  @param {Element} element
  @experimental
  ###
  hide = (element) ->
    element.style.display = 'none'

  ###**
  Shows the given element.

  The element is shown by setting an [inline style](https://www.codecademy.com/articles/html-inline-styles)
  of `{ display: '' }`.

  You might have CSS rules causing the element to remain hidden after calling `up.element.show(element)`.
  Unpoly will not handle such cases in order to keep this function performant. As a workaround, you may
  manually set the `element.style.display` property. Also see discussion
  in jQuery issues [#88](https://github.com/jquery/jquery.com/issues/88),
  [#2057](https://github.com/jquery/jquery/issues/2057) and
  [this WHATWG mailing list post](http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Apr/0094.html).

  @function up.element.show
  @experimental
  ###
  show = (element) ->
    element.style.display = ''

  ###**
  Display or hide the given element, depending on its current visibility.

  @function up.element.toggle
  @param {Element} element
  @param {Boolean} [newVisible]
    Pass `true` to show the element or `false` to hide it.

    If omitted, the element will be hidden if visible and shown if invisible.
  @experimental
  ###
  toggle = (element, newVisible) ->
    newVisible ?= !isVisible(element)
    if newVisible
      show(element)
    else
      hide(element)

#  trace = (fn) ->
#    (args...) ->
#      console.debug("Calling %o with %o", fn, args)
#      fn(args...)

  ###**
  Adds or removes the given class from the given element.

  If you don't need IE11 support you may also use the built-in
  [`Element#classList.toggle(className)`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) to the same effect.


  @function up.element.toggleClass
  @param {Element} element
    The element for which to add or remove the class.
  @param {String} className
    A boolean value to determine whether the class should be added or removed.
  @param {String} state
    If omitted, the class will be added if missing and removed if present.
  @experimental
  ###
  toggleClass = (element, klass, newPresent) ->
    list = element.classList
    newPresent ?= !list.contains(klass)
    if newPresent
      list.add(klass)
    else
      list.remove(klass)

  ###**
  @function up.element.setAttrs
  @experimental
  ###
  setAttrs = (element, attrMap) ->
    for key, value of attrMap
      element.setAttribute(key, value)

  ###**
  @function up.element.metaContent
  @internal
  ###
  metaContent = (name) ->
    selector = "meta" + attributeSelector('name', name)
    first(selector)?.getAttribute('content')

  ###**
  @function up.element.insertBefore
  @internal
  ###
  insertBefore = (existingElement, newElement) ->
    existingElement.insertAdjacentElement('beforebegin', newElement)

#  insertAfter = (existingElement, newElement) ->
#    existingElement.insertAdjacentElement('afterend', newElement)

  ###**
  Replaces the given old element with the given new element.

  The old element will be removed from the DOM tree.

  If you don't need IE11 support you may also use the built-in
    [`Element#replaceWith()`](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/replaceWith) to the same effect.

  @function up.element.replace
  @param {Element} oldElement
  @param {Element} newElement
  @experimental
  ###
  replace = (oldElement, newElement) ->
    oldElement.parentElement.replaceChild(newElement, oldElement)

  ###**
  @function up.element.setAttrs
  @experimental
  ###
  setAttrs = (element, attrs) ->
    for name, value of attrs
      element.setAttribute(name, value)

  ###**
  @function up.element.createFromSelector
  @experimental
  ###
  createFromSelector = (givenSelector, attrs) ->
    # Extract attribute values before we do anything else.
    # Attribute values might contain spaces, and then we would incorrectly
    # split depths at that space.
    attrValues = []
    selectorWithoutAttrValues = givenSelector.replace /\[([\w-]+)(?:=(["'])?([^"'\]]*?)\2)?\]/g, (_match, attrName, _quote, attrValue) ->
      attrValues.push(attrValue || '')
      "[#{attrName}]"

    depths = selectorWithoutAttrValues.split(/[ >]+/)
    rootElement = undefined
    depthElement = undefined
    previousElement = undefined

    for depthSelector in depths
      tagName = undefined

      depthSelector = depthSelector.replace /^[\w-]+/, (match) ->
        tagName = match
        ''

      depthElement = document.createElement(tagName || 'div')
      rootElement ||= depthElement

      depthSelector = depthSelector.replace /\#([\w-]+)/, (_match, id) ->
        depthElement.id = id
        ''

      depthSelector = depthSelector.replace /\.([\w-]+)/g, (_match, className) ->
        depthElement.classList.add(className)
        ''

      # If we have stripped out attrValues at the beginning of the function,
      # they have been replaced with the attribute name only (as "[name]").
      if attrValues.length
        depthSelector = depthSelector.replace /\[([\w-]+)\]/g, (_match, attrName) ->
          depthElement.setAttribute(attrName, attrValues.shift())
          ''

      unless depthSelector == ''
        throw new Error('Cannot parse selector: ' + givenSelector)

      previousElement?.appendChild(depthElement)
      previousElement = depthElement

    if attrs
      if classValue = u.pluckKey(attrs, 'class')
        for klass in u.wrapList(classValue)
          rootElement.classList.add(klass)
      if styleValue = u.pluckKey(attrs, 'style')
        setInlineStyle(rootElement, styleValue)
      if textValue = u.pluckKey(attrs, 'text')
        rootElement.innerText = textValue
      setAttrs(rootElement, attrs)

    rootElement

  ###**
  @function up.element.affix
  @experimental
  ###
  affix = (container, selector, options) ->
    element = createFromSelector(selector, options)
    container.appendChild(element)
    element

  ###**
  Returns a CSS selector that matches the given element as good as possible.

  This uses, in decreasing order of priority:

  - The element's `up-id` attribute
  - The element's ID
  - The element's name
  - The element's classes
  - The element's tag names

  @function up.element.toSelector
  @param {string|Element|jQuery}
    The element for which to create a selector.
  @experimental
  ###
  toSelector = (element) ->
    return element if u.isString(element)

    # resolveSelector() might be called with jQuery collections
    element = getOne(element)

    selector = undefined

    if isSingleton(element)
      selector = elementTagName(element)
    else if upId = element.getAttribute("up-id")
      selector = attributeSelector('up-id', upId)
    else if id = element.getAttribute("id")
      if id.match(/^[a-z0-9\-_]+$/i)
        selector = "##{id}"
      else
        selector = attributeSelector('id', id)
    else if name = element.getAttribute("name")
      selector = elementTagName(element) + attributeSelector('name', name)
    else if classes = u.presence(nonUpClasses(element))
      selector = ''
      for klass in classes
        selector += ".#{klass}"
    else if ariaLabel = element.getAttribute("aria-label")
      selector = attributeSelector('aria-label', ariaLabel)
    else
      selector = elementTagName(element)

    return selector

  ###**
  @function up.element.isSingleton
  @internal
  ###
  isSingleton = (element) ->
    matches(element, 'html, body, head, title')

  elementTagName = (element) ->
    element.tagName.toLowerCase()

  ###**
  @function up.element.attributeSelector
  @internal
  ###
  attributeSelector = (attribute, value) ->
    value = value.replace(/"/g, '\\"')
    "[#{attribute}=\"#{value}\"]"

  nonUpClasses = (element) ->
    classString = element.className
    classes = u.splitValues(classString)
    u.reject classes, (klass) -> klass.match(/^up-/)

  ###**
  @function up.element.createDocumentFromHtml
  @internal
  ###
  createDocumentFromHtml = (html) ->
    # IE9 cannot set innerHTML on a <html> or <head> element.
    parser = new DOMParser()
    return parser.parseFromString(html, 'text/html')

  ###**
  @function up.element.createFromHtml
  @experimental
  ###
  createFromHtml = (html) ->
    doc = createDocumentFromHtml(html)
    return doc.body.children[0]

  ###**
  @function up.element.root
  @internal
  ###
  getRoot = ->
    document.documentElement

  ###**
  Forces the browser to paint the given element now.

  @function up.element.paint
  @internal
  ###
  paint = (element) ->
    element.offsetHeight

  ###**
  @function up.element.concludeCssTransition
  @internal
  ###
  concludeCssTransition = (element) ->
    undo = setTemporaryStyle(element, transition: 'none')
    # Browsers need to paint at least one frame without a transition to stop the
    # animation. In theory we could just wait until the next paint, but in case
    # someone will set another transition after us, let's force a repaint here.
    paint(element)
    return undo

  ###**
  Returns whether the given element has a CSS transition set.

  @function up.util.hasCssTransition
  @return {boolean}
  @internal
  ###
  hasCssTransition = (elementOrStyleHash) ->
    if u.isOptions(elementOrStyleHash)
      styleHash = elementOrStyleHash
    else
      styleHash = computedStyle(elementOrStyleHash)

    prop = styleHash.transitionProperty
    duration = styleHash.transitionDuration
    # The default transition for elements is actually "all 0s ease 0s"
    # instead of "none", although that has the same effect as "none".
    noTransition = (prop == 'none' || (prop == 'all' && duration == 0))
    not noTransition

  ###**
  @function up.util.fixedToAbsolute
  @internal
  ###
  fixedToAbsolute = (element) ->
    elementRectAsFixed = element.getBoundingClientRect()

    # Set the position to 'absolute' so it gains an offsetParent
    element.style.position = 'absolute'

    offsetParentRect = element.offsetParent.getBoundingClientRect()

    setInlineStyle element,
      left: elementRectAsFixed.left - computedStyleNumber(element, 'margin-left') - offsetParentRect.left
      top: elementRectAsFixed.top - computedStyleNumber(element, 'margin-top') - offsetParentRect.top
      right: ''
      bottom: ''

  ###**
  On the given element, set attributes that are still missing.

  @function up.element.setMissingAttrs
  @internal
  ###
  setMissingAttrs = (element, attrs) ->
    for key, value of attrs
      if u.isMissing(element.getAttribute(key))
        element.setAttribute(key, value)

  ###**
  @function up.element.unwrap
  @internal
  ###
  unwrap = (wrapper) ->
    parent = wrapper.parentNode;
    wrappedNodes = u.toArray(wrapper.childNodes)
    u.each wrappedNodes, (wrappedNode) ->
      parent.insertBefore(wrappedNode, wrapper)
    parent.removeChild(wrapper)

  ###**
  Returns the value for the given element and attribute, if it is present.

  If it is blank it returns `undefined`.

  @function up.util.presentAttr
  @experimental
  ###
  presentAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    u.presence(value)

  ###**
  @function up.util.booleanAttr
  @experimental
  ###
  booleanAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    switch value
      when 'false' then false
      when 'true', '', attribute then true
      else value # other strings, undefined, null, ...

  ###**
  @function up.util.numberAttr
  @experimental
  ###
  numberAttr = (element, attribute) ->
    value = element.getAttribute(attribute)
    if value?.match(/^[\d\.]+$/)
      parseFloat(value)

  ###**
  Reads the given attribute from the element, parsed JSON.

  Returns `undefined` if the attribute value is [blank](/up.util.isBlank).

  @function up.element.jsonAttr
  @experimental
  ###
  jsonAttr = (element, attribute) ->
    # The document does not respond to #getAttribute()
    if json = element.getAttribute?(attribute)?.trim()
      JSON.parse(json)

  ###**
  Temporarily sets the CSS for the given element.

  @function up.util.setTemporaryStyle
  @param {jQuery} $element
  @param {Object} css
  @param {Function} [block]
    If given, the CSS is set, the block is called and
    the old CSS is restored.
  @return {Function}
    A function that restores the original CSS when called.
  @experimental
  ###
  setTemporaryStyle = (element, newCss, block) ->
    oldStyles = inlineStyle(element, Object.keys(newCss))
    restoreOldStyles = -> setInlineStyle(element, oldStyles)
    setInlineStyle(element, newCss)
    if block
      # If a block was passed, we run the block and restore old styles.
      block()
      restoreOldStyles()
    else
      # If no block was passed, we return the restoration function.
      restoreOldStyles

  ###**
  Gets the computed style(s) for the given element.

  @function up.element.style
  @param {jQuery|Element} element
  @param {String|Array} propOrProps
    One or more CSS property names in camelCase.
  @return {string|object}
  @experimental
  ###
  computedStyle = (element, props) ->
    element = up.element.get(element)
    style = window.getComputedStyle(element)
    extractFromStyleObject(style, props)

  ###**
  Gets a computed style value for the given element.
  If a value is set, the value is parsed to a number before returning.

  @function up.element.styleNumber
  @param {jQuery|Element} element
  @param {String} prop
    A CSS property name in camelCase.
  @return {string|object}
  @experimental
  ###
  computedStyleNumber = (element, prop) ->
    rawValue = computedStyle(element, prop)
    if u.isGiven(rawValue)
      parseFloat(rawValue)
    else
      undefined

  ###**
  Gets the given inline style(s) from the given element's `[style]` attribute.

  @function up.element.inlineStyle
  @param {jQuery|Element} element
  @param {String|Array} propOrProps
    One or more CSS property names in camelCase.
  @return {string|object}
  @internal
  ###
  inlineStyle = (element, props) ->
    element = up.element.get(element)
    style = element.style
    extractFromStyleObject(style, props)

  extractFromStyleObject = (style, keyOrKeys) ->
    if u.isString(keyOrKeys)
      style[keyOrKeys]
    else # array
      u.only(style, keyOrKeys...)

  ###**
  Merges the given inline style(s) into the given element's `[style]` attribute.

  @function up.element.setStyle
  @param {jQuery|Element} element
  @param {Object} props
    One or more CSS properties with camelCase keys.
  @return {string|object}
  @experimental
  ###
  setInlineStyle = (element, props) ->
    element = up.element.get(element)
    style = element.style
    for key, value of props
      value = normalizeStyleValueForWrite(key, value)
      style[key] = value

  normalizeStyleValueForWrite = (key, value) ->
    if u.isMissing(value)
      value = ''
    else if CSS_LENGTH_PROPS.has(key)
      value = cssLength(value)
    value

  CSS_LENGTH_PROPS = u.arrayToSet [
    'top', 'right', 'bottom', 'left',
    'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
    'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',
    'width', 'height',
    'maxWidth', 'maxHeight',
    'minWidth', 'minHeight',
  ]

  ###**
  Converts the given value to a CSS length value, adding a `px` unit if required.

  @function up.util.cssLength
  @internal
  ###
  cssLength = (obj) ->
    if u.isNumber(obj) || (u.isString(obj) && /^\d+$/.test(obj))
      obj.toString() + "px"
    else
      obj

  ###**
  Resolves the given CSS selector (which might contain `&` references)
  to a full CSS selector without ampersands.

  If passed an `Element` or `jQuery` element, returns a CSS selector string
  for that element.

  @function up.element.resolveSelector
  @param {string|Element|jQuery} selectorOrElement
  @param {string|Element|jQuery} origin
    The element that this selector resolution is relative to.
    That element's selector will be substituted for `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @return {string}
  @internal
  ###
  resolveSelector = (selectorOrElement, origin) ->
    if u.isString(selectorOrElement)
      selector = selectorOrElement
      if u.contains(selector, '&')
        if u.isPresent(origin) # isPresent returns false for empty jQuery collection
          originSelector = toSelector(origin)
          selector = selector.replace(/\&/, originSelector)
        else
          up.fail("Found origin reference (%s) in selector %s, but no origin was given", '&', selector)
    else
      selector = toSelector(selectorOrElement)
    selector

  ###**
  Returns whether the given element is currently visible.

  An element is considered visible if it consumes space in the document.
  Elements with `{ visibility: hidden }` or `{ opacity: 0 }` are considered visible, since they still consume space in the layout.

  Elements not attached to the DOM are considered hidden.

  @function up.element.isVisible
  @param {Element|string|jQuery} element
    The element to check.
  @experimental
  ###
  isVisible = (element) ->
    # From https://github.com/jquery/jquery/blame/9cb162f6b62b6d4403060a0f0d2065d3ae96bbcc/src/css/hiddenVisibleSelectors.js#L12
    !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length)

  <% if ENV['JS_KNIFE'] %>knife: eval(Knife.point)<% end %>
  # also document :has()!
  first: first # same as document.querySelector
  all: all # same as document.querySelectorAll
  subtree: subtree # practical
  closest: closest # needed for IE11
  matches: matches # needed for IE11
  ancestor: ancestor # not practical. we use it to implement closest
  get: getOne # practical for code that also works with jQuery
  list: getList # practical for composing multiple collections, or wrapping.
  remove: remove # needed for IE11
  toggle: toggle # practical
  toggleClass: toggleClass # practical
  hide: hide # practical
  show: show # practical
  setAttrs: setAttrs # practical
  metaContent: metaContent # internal
  replace: replace # needed for IE11
  insertBefore: insertBefore # internal shortcut, people can use insertAdjacentElement and i don't want to support insertAfter when I don't need it.
  createFromSelector: createFromSelector # practical for element creation.
  setAttrs: setAttrs # practical
  affix: affix # practical for element creation
  toSelector: toSelector # practical
  isSingleton: isSingleton # internal
  attributeSelector: attributeSelector # internal
  createDocumentFromHtml: createDocumentFromHtml # internal
  createFromHtml: createFromHtml # practical for element creation
  root: getRoot # internal
  paint: paint # internal
  concludeCssTransition: concludeCssTransition # internal
  hasCssTransition: hasCssTransition # internal
  fixedToAbsolute: fixedToAbsolute # internal
  setMissingAttrs: setMissingAttrs # internal
  unwrap: unwrap # practical for jQuery migration
  presentAttr: presentAttr # experimental
  booleanAttr: booleanAttr # it's practical, but i cannot find a good name. people might expect it to cast to number, too. but i don't need that for my own code. maybe booleanAttr?
  numberAttr: numberAttr # practical
  jsonAttr: jsonAttr # practical
  setTemporaryStyle: setTemporaryStyle # practical
  style: computedStyle # practical.
  styleNumber: computedStyleNumber # practical.
  inlineStyle: inlineStyle # internal
  setStyle: setInlineStyle # practical.
  resolveSelector: resolveSelector # internal
  none: -> NONE # internal
  isVisible: isVisible # practical

